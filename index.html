
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>MR SHIH</title>
  <meta name="author" content="施安宏">

  
  <meta name="description" content="iOS 8之後搭配UISearchController，只要把屬性searchResultsUpdater指定物件在updateSearchResultsForSearchController這個方法中實作filtering and updating就可以了。非常方便。 Fetch data &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://sah.tw">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="MR SHIH" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-31868165-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">MR SHIH</a></h1>
  
    <h2>必幸施</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:sah.tw" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/25/search/">iOS Search應用初探</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-01-25T18:18:02+08:00" pubdate data-updated="true">Jan 25<sup>th</sup>, 2017</time>
        
           | <a href="/blog/2017/01/25/search/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2017/01/25/search/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>iOS 8之後搭配<code>UISearchController</code>，只要把屬性<code>searchResultsUpdater</code>指定物件在<code>updateSearchResultsForSearchController</code>這個方法中實作filtering and updating就可以了。非常方便。</p>

<h3>Fetch data</h3>

<p>從Server抓取資料，這裡我們用<code>originalDatas</code>這個instace variable存JSON陣列資料。注意Retain Cycle即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Feth data from server and reload.
</span><span class='line'>__weak MemberListTableViewController *weakSelf = self;
</span><span class='line'>[TNUserManager logInAccountInBackgroundWithAccount:@"andy" password:@"12344321" success:^{
</span><span class='line'>    [TNUserManager getContactbookWithSuccess:^(NSDictionary *responseObject) {
</span><span class='line'>        weakSelf.originalDatas = (NSArray*)responseObject;
</span><span class='line'>        [weakSelf.tableView reloadData];
</span><span class='line'>    } failure:^(ResultInfo *resultInfo) {
</span><span class='line'>        NSLog(@"get data fail");
</span><span class='line'>    }];
</span><span class='line'>} failure:^(ResultInfo *resultInfo) {
</span><span class='line'>    NSLog(@"login fail");
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h3>Filtering and Updating</h3>

<p>利用<code>NSPredicate</code>制定陣列搜尋規則，這裡是指定陣列內有包涵<code>searchString</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** Filtering **/
</span><span class='line'>// 搜尋規則
</span><span class='line'>NSPredicate *preicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searchString];
</span><span class='line'>
</span><span class='line'>// 搜尋
</span><span class='line'>NSMutableArray *reslut = [[NSMutableArray alloc]init];
</span><span class='line'>// loop each people
</span><span class='line'>for (NSDictionary *each in self.originalDatas) {
</span><span class='line'>    Boolean isMatch = false;
</span><span class='line'>    
</span><span class='line'>    // list all value of people
</span><span class='line'>    NSMutableArray *values = [NSMutableArray arrayWithArray:[each allValues]];
</span><span class='line'>    
</span><span class='line'>    // 把property的屬性為array的提取出來
</span><span class='line'>    for (id proerty in values) {
</span><span class='line'>        if ([proerty isKindOfClass:[NSArray class]]) {
</span><span class='line'>            if ([proerty filteredArrayUsingPredicate:preicate].count &gt; 0) {
</span><span class='line'>                // show
</span><span class='line'>                isMatch = true;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // 找剩下property的屬性為string的
</span><span class='line'>    if (isMatch == false) {
</span><span class='line'>        if ([values filteredArrayUsingPredicate:preicate].count &gt; 0) {
</span><span class='line'>            // show
</span><span class='line'>            isMatch = true;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    if (isMatch) {
</span><span class='line'>        [reslut addObject:each];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/** Updateing **/
</span><span class='line'>self.showDatas = [reslut mutableCopy];
</span><span class='line'>[self.tableView reloadData];</span></code></pre></td></tr></table></div></figure>


<h3>後續優化idea</h3>

<p>這個APP是做公司內部通訊錄的，而如果陣列裡面包涵員工ID，或到職日期等數字資料，就可以在<code>NSPredicate</code>字串比對完之後，搭配<a href="http://sah.tw/blog/2016/11/09/objc-quick-sort/">Sorting</a>來對數字做排序。</p>

<p>潮一點的搞個數據應用，可以把搜尋歷史用SQLite記錄下來，把<code>搜尋後而且點擊</code>這個元素加入到Sorting的條件中。這樣一來使用者越長搜尋的排序就會越前面囉。</p>

<p>最後也可以做成<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/index.html#//apple_ref/doc/uid/TP40016308">讓iOS系統搜尋Bar也可以找到APP內的資訊</a>，不過這樣就要把通訊錄存在本地端DB，而不能只是In-Memory JSON處理了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/17/why-love-mma-gym/">為何愛成吉思汗健身房</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-01-17T23:21:00+08:00" pubdate data-updated="true">Jan 17<sup>th</sup>, 2017</time>
        
           | <a href="/blog/2017/01/17/why-love-mma-gym/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2017/01/17/why-love-mma-gym/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://mrshih.github.io/images/2017-01-17-why-love-mma-gym.jpg" alt="image" /></p>

<p>成吉思汗的館長說他開館就是相信台灣應該擁有更好健身房，所以要持續的提供台灣一個高水準的健身聖地，提升台灣人健身運動的專業風氣。討厭看到市場上充斥的都是直銷與只想賺錢的商業健身房與似是而非的健身觀念。</p>

<p>之前去過其他健身房，別的可能就是放很養眼的美女帥男圖，可能也會放勵志標語，比如今天得努力是為了什麼。但我特別喜歡成吉思汗該怎麼做就怎麼做的實幹精神，健身就是會苦，有苦才有收穫。每個人來這裡都是在跟自己比賽，而不是只是來打發時間。我們選擇在此時此刻來到這個健身房，是要互相見證彼此在痛苦中成長，我們能互相體會別人在力竭時努力的叫喊，猙獰的臉龐，而不會阿呦，這是在幹嘛。在這裡大家都在玩真的，真得都在健身，很有熱情想法的在看待這件事！沒有再跟你害羞，沒有再跟你玩半套。在這裡許多地方標語就是no pain no gain。</p>

<p>在這裡密集的上教練課，與教練聊天中知道這裡教練對於定期的考試大家都十分重視，不只是玩玩只求過就好，大家都追求好成績，互相幫忙當捕手教學對方不足之處，這裡教練是真心在追求身體上的進化與突破，跟著這樣的教練才能有學不完的東西，而我相信能夠不斷自我要求的環境這就是好的環境。</p>

<p>成吉思汗直接把台灣制霸印在門口，器材真多超多超齊全，妥善率也都很好，深蹲架排開就是五台，而全年保證不休息，想練隨時都可以來練，就連年過年除夕都不打烊，教練師資真的也專業又敬業。</p>

<h3>為何寫這篇？</h3>

<p>之所以打這一篇是因為跟一位熱愛運動但在考慮上健身房的朋友聊天，偶然聊到為什麼這麼多健身房我選擇了在三重沒有離我家很近的成吉思汗，我突然發現儘管我十分認同喜歡這裡，但我卻完全沒有辦法引起別人的共鳴。後來思考，這應該跟<a href="https://www.youtube.com/watch?v=qp0HIF3SfI4">Simon Sinek那個演講</a>想表達的是一樣。</p>

<p>我都是從WHAT跟HOW來開始跟別人講解，提陳吉思汗優點從有大量專業的器材，很壯的教練，口碑也都不錯的切入，我從WHAT跟HOW切入，結果就是聽的人不能感受成吉思汗特別得地方。我試著從WHY這個角度切入，也希望下次我再推坑其他的人的時候能更引起別人共鳴，推坑成功。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/01/ai/">超級智能時代-人工智慧的不可擋與半世紀影響</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-01-01T18:56:12+08:00" pubdate data-updated="true">Jan 1<sup>st</sup>, 2017</time>
        
           | <a href="/blog/2017/01/01/ai/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2017/01/01/ai/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://mrshih.github.io/images/2017-01-02-ai.markdown.JPG" alt="image" /></p>

<p>談一本重要的書，超級智能時代，這本書裡談的議題對每一位讀者都絕對切身相關。人類剛經過一波的資訊革命，最近幾年資訊技術的成熟發展，包含移動網路與終端設備如手機的成熟，帶來資訊大爆炸。資訊大爆炸後有了足夠的數據量，收集起來嘗試找出某些規則，並運用這些規則來使人類生活更方便，也賺取了大把財富。</p>

<p>但從工業時代以來的每一波革命都是先造福一小部分群眾，過了許多年後全人類才能享有革命帶來的好處。這一波大數據與人工智慧的革命帶來的影響與衝擊非常之廣，人工智慧就是想解決以往人類才能解決的問題，會取代許多既有的勞動力，再疊加上一波資訊革命帶來的影響，根據歷史可以想見需要長達半世紀來消化過剩勞動力帶來的負面衝擊。</p>

<h3>從因果法到逆推法</h3>

<p>以往人類學習的方式是習慣先假設某種道理，之後再去累積數據去證明出這種道理;我們習慣先假設因，才去驗證結果。上幾個世紀人類都習慣這套思考模式，稱之為工業時代思考模式。而當時間來到現在，容易尋找的真理幾乎都被發現完了，我們要面對的是不確定性越來越高的問題，往往我們連問題該怎麼定義都沒有頭緒，所以藉由累積數據來說故事，從資料裡發現道理，便是為了回答現代越發複雜，且不確定性極高的智慧型問題的新思考模式。</p>

<h3>現代人工智慧</h3>

<p>其實大數據不是用來解決人工智慧的唯一方法。最早其實科學家是想模仿人類思考模式來製造人工智慧，但發現難以解決不確性高的問題。而隨著硬體如儲存技術得成熟，連結技術如移動網路的成熟，處理能力如資料中心的成熟，這三者技術同時準備好了，使得人類發現與其讓機器造著人類的想法走，不如餵給機器一堆資料，讓它從中自己試著回答問題，結果比之前的方法就結果來說都更好。</p>

<p>逆推方方法論變成資訊時代的方法論。</p>

<p>順著這個思考模式可以發現。掌握數據，更嚴格來講是大數據的人在未來才有可能回答現代社會中越發複雜的問題。大數據顧命思議就是大量的資料，而大量的數據加上多維度，便能從中去試著找出規律，總結成智慧。</p>

<p>所以從人工智慧方向往大數據的逆推方法論走後，『人類在人工智慧領域的成就，其實就是把各種智慧問題轉化為消除不確定性的問題，然後再找到能消除相應不確定性的資訊』。</p>

<p>下圍棋人類依靠經驗與眾多棋譜來學習如何取勝，而只要能把棋譜轉換成電腦可懂的規則，電腦就可以大量的去讀取歷史棋譜，能比任何人類一輩子讀的都還要多，最後轉換成數學模式，採用依照大量數據訓練加上統計知識所做出來的模型來回答問題。雖然棋的變化是無窮的，但機器總能找出勝率較高的步法。</p>

<p>AlphaGo在比賽中走出許多令人類專家跌破眼鏡的走法，但最後又能贏。這裡重點在於機器不必像人一樣思考，只要能夠解決人的問題就好了。在大數據中得出的智慧是數據加上統計的及果，是有可能出乎人意料外的，而且能做的更好。能不照常規行事其實就是超級智慧的表現。</p>

<p>而AlphaGo知道自己在下棋嗎？當然不知道。只不過把智慧問題轉換成數據問題。用統計方法搭配大數據解決智慧問題後機器從此無敵。</p>

<p>所以對於行事有特定SOP的技能，也就是非創造性工作的從業人員，大數據加上人工智慧是大有取代的勢頭。比如基金操盤手、醫師、會計師、司機、護士、農夫等。</p>

<h3>智能革命的影響</h3>

<p>在未來掌握大數據與運算能力的少數巨頭，目前來看如Google, FB, Apple, Amazon, Netflex和大陸的bat，這些公司如果和公權力結合，那就是全面監控了。CIA要來台灣抓人其實不用跟台灣警察打交道，透過你使用的手機說不定還比台灣警察更知道你的所在地。免費的服務往往是用自由換來的。你提供時間與數據，巨頭提供免費服務。在未來隱私的保護是重要議題。</p>

<p>技術帶來的各命常常是憂喜參半，喜的是改善人類生活，讓一些處在浪尖的人發揮更大的作用。但因為技術進步而被取代的人力，往往沒有辦法在學習新技術，所以只好『養著』，耗上兩代就解決問題了。</p>

<p>這次的超級智能最重要的影響是人類會發現自己能做得比機器好的事情不多了，很多人會在技術進步的途中發現自己被拋下了，新技術的發展不是每個人的機會都會變多，許多人反而是機會變少，如全自動化工廠之於生產線工人，計程車司機之於自動駕駛技術。這些大量勞動力該如何解決？書中其實沒有提出解決辦法，只能接受接在未來的幾10年會有越來越多事人類贏不了機器人。而之後所做的決定也都要依照這個大前提去行動。</p>

<h3>對於我個人</h3>

<p>看完這本書心中是興奮與恐懼，興奮的是對未來人類生活充滿正面積極的想像，恐懼的是害怕自己是對這未來至少50年影響人類最深遠的領域一無所知，最終被拋下，在自己的工作生涯毫不自豪。幸好我是相關科系相關產業，也還年輕肯學有興趣，往後推10年的努力都要與人工智能領域有關，投入在相關領域是我對自己未來的規劃。</p>

<p>以下是Youtube連結，台大教授林軒田老師的<a href="https://www.youtube.com/playlist?list=PLXVfgk9fNX2I7tB6oIINGBmW50rrmFTqf">機器學習基石</a> FYI。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/12/27/airpods/">AirPods個人使用評測：『能夠預知下一步的真智慧型耳機』</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-12-27T17:19:23+08:00" pubdate data-updated="true">Dec 27<sup>th</sup>, 2016</time>
        
           | <a href="/blog/2016/12/27/airpods/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2016/12/27/airpods/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://mrshih.github.io/images/2016-12-27-airpods.jpg" alt="image" /></p>

<p>說到無線藍芽耳機我也是重度愛好者，早在前年就花了5位數大洋買了Sony的藍芽耳罩耳機<code>MDR-1RBTMK2</code>，那時候最麻煩的地方在於配對的不穩定和麻煩，都要先按鈕換醒耳機等待手機配對，有時找不到還要自己去連線。還有麥克風根本是雞肋，完全不能拿來講電話收音非常差，一有電話打來常常是手忙腳亂拔耳機選擇本機的Mic等等&hellip;好在上述的問題在AirPods都被完美的解決了。</p>

<h3>方便到一切成自然的拔掉單邊耳機</h3>

<p>常常戴耳機遇到一個情況是別人突然來找你講話，這時候拿掉一邊耳機另一邊都還播著歌，有時還是要手動把音樂關掉，而AirPods你只要拿掉其中一邊耳機，手機立即就會停止播放歌曲，真的是很實用的功能。</p>

<p>再來重點當你講完話，把耳機再放回耳朵時，音樂又會聰明的自動開始播放了！一切真的就是方便到成自然。想像你帶著耳機在電影，突然有人打擾！你帥氣的拿下單邊耳機電影立刻自動暫停，講完之後再戴回去電影立刻繼續播放！Magic~</p>

<p>你的下一個動作都預先被做好了，對我來說這就是智慧型產品，就叫方便！</p>

<h3>兩邊耳機都拿掉</h3>

<p>以前我用過的藍牙耳機當你兩邊都拿掉之後，你可能就是回到家不需要他們了，這時還要去手機裡面把輸出模式切換為原本的喇叭，多此一舉。而AirPods會自動偵測到你把兩邊耳機都拿掉了，iOS Device會自動把輸出切換回本機的模式。日常使用起來也是非常方便。</p>

<h3>麥克風</h3>

<p>真的很神奇，明明麥克風不在你嘴邊是在耳朵旁，可是你講出來的話還是很清楚的被收音了。使用AirPods後講了很多電話沒有人跟我反應不清楚。最後如果特別有問都會說我這邊收音很清楚很清晰。不管在捷運上或大馬路或安靜辦公室裡都OK的。</p>

<h3>連線穩定度</h3>

<p>搭配iOS Device很穩，就是穩。我想這是基本的啦。</p>

<h3>音質</h3>

<p>高音感受與有線一樣，低音感受比有線好蠻多的，至少我有感啦。音質很主觀，很在意的還是親耳聽聽吧。如果可以接受原廠有線的，那AirPods這個應該沒問題。</p>

<h3>電力與充電</h3>

<p>AirPods本身支援快充，你聽到剩4%快沒電了，放回AirPods case（就上面那個方形小盒子），約不到15分鐘就充超過一半了。充滿一次可以聽大概5個小時。實際使用上跟官方給的數據都很相近。自己用起來完全不擔心缺電。</p>

<h3>外觀</h3>

<p>這個就不用太在意吧，音樂是自己在聽的，而且也不是什麼新設計，就是之前有線的長相呀，只是沒有線。真的很在意的就等多一點人戴再買吧，哈哈。按照官網購買要排到6個禮拜後的情況，我想以後路上會很常看到的。</p>

<h3>會不會掉？醒著的時候都不會掉</h3>

<p>什麼意思勒？我帶著AirPods慢步，重訓（有時需要躺著），出門坐捷運加上走一大段路，尖峰時刻搭捷運有時難免跟路人碰撞，以上情況都沒有掉過！有線的反而常常搭捷運太擠線勾到還會被扯掉。</p>

<p>唯獨有一次搭客運睡著頭往一邊肩膀倒，然後客運晃阿晃抖阿抖的，那邊的AirPods就掉了&hellip;嚇出一身冷汗，還好那天穿帽T醒來之後AirPods還在我肩膀上。所以，如果你快睡著又剛好身體會晃來晃去就要注意一點了。</p>

<h3>快速跨多裝置使用超方便</h3>

<p>如果你同時有Macbook, iPhone, iPad，而且都使用同一個有線耳機，常常插拔真的頗麻煩。AidPods只要Device都使用同一個Apple ID，每個裝置都不用再額外配對就可以很快速的連接上你的AirPods。</p>

<p>我常常很賭爛Macbook上的耳機孔，真的很難拔，常常只是要上個廁所我就要拔下來再插上手機，回到座位上又要Repeat這個動作。有了AirPods之後就超方便的，只要手機帶著就自動會有AirPods選項讓你選，點一下就切換到手機上了。</p>

<h3>缺點</h3>

<p>使用下來真的沒有感受到什麼缺點，對比有線耳機只有更方便更智慧的感受。真要說的話就是AirPods上面沒有按鈕可以按，也就是說沒有傳統有線上的上下首與大小聲按鈕。AirPods現在只能感應點兩下這個動作，點兩下來叫出Siri或是點兩下暫停/播放。</p>

<p>雖然說是缺點但我的習慣是出門手上都會拿著耳機，基本上手機不離身，所以要上下一首或調音量，把畫面喚醒就可以直接操作了，實際使用上其實也沒有感覺到不便。</p>

<h3>總結</h3>

<p>毆對了！還有價錢。5000多大洋就是考驗每個人用錢價值觀的時刻了。上面舉了那些優點還有缺點，我只能說差不多的錢就功能上還有方便性智慧性等，目前市面上我認為還沒有競爭對手。</p>

<p>對我來說，耳機是我每天必用到的東西，如果每天都能少那麼一點煩惱，比如花時間解開那一坨線, 插拔的動作, 有時會扯到, 原廠有線用久其實真的很容易接觸不良還是要買新的等等，加上上面提的優點，OK 我買單。</p>

<p>我不算盲目的果粉，近期Apple的產品包含iPhone 7跟新Macbook如果有人詢問我意見我都會叫他們再等等，但這個AirPods真的很推，Apple近期難得好作品，預算夠我都會推薦買Der~。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/20/youtubeshi-yong-tabbar/">從Youtube使用Tabbar討論逐漸被棄用的側邊欄</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-11-20T11:56:52+08:00" pubdate data-updated="true">Nov 20<sup>th</sup>, 2016</time>
        
           | <a href="/blog/2016/11/20/youtubeshi-yong-tabbar/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2016/11/20/youtubeshi-yong-tabbar/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>側邊欄逐漸被棄用的原因</h2>

<p>iOS版YouTube把Tabbar加上去了。前陣子流行的各種想取代Tabbar導航方式的方案又改回來了。</p>

<p><img src="http://mrshih.github.io/images/2016-11-20-youtubeshi-yong-tabbar.jpeg" alt="image" /></p>

<p>Tabbar是固定出現在下面的（除了播放影片時）。而看了些文章，最主要還是用戶真的太太太太懶，多一丁點步驟都懶得按，所以就乾脆固定在那裡。這樣努力做的各種功能的使用率比較高！</p>

<p>不過Uber是個有趣的例子！Uber用漢堡是因為其他功能的點擊率高不是goal，所以可以用Hamburger menu。</p>

<h2>如何決定要用哪種設計？A/B Testing</h2>

<p>Youtube跟Spotify決定從原本側邊欄轉移到Tabbar都是因為測過A/B Testing，用結果數字來說話。</p>

<p>這其實也牽扯到如何設計A/B Testing？一個APP最關鍵的不是他介面看起來炫不炫，而是最終用戶能不能持續地用你想讓他用的功能。記住If<strong><strong> ,Then</strong></strong> ,Because___.</p>

<p>如果你的變因錯誤的把畫面好看當成目標，那你甚至會覺得隨著畫面滾動把Tabbar隱藏起來是好的。那這樣一來或許畫面變好看，可是面積變多，但你APP整體功能使用率是下降的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/18/binary-searchyu-obj-c/">Binary search與Obj-C</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-11-18T16:41:19+08:00" pubdate data-updated="true">Nov 18<sup>th</sup>, 2016</time>
        
           | <a href="/blog/2016/11/18/binary-searchyu-obj-c/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2016/11/18/binary-searchyu-obj-c/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Binary search概念</h2>

<p>Binary search概念其實很簡單，recursive版本實際寫起來很像<a href="http://sah.tw/blog/2016/11/09/objc-quick-sort/">Quick sort in-place</a>版本前面divide的味道。每次的遞迴都把排序後的數列對切一半然後去其中一半來繼續處理，詳細可以看<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">Wiki</a>的介紹。</p>

<h2>Binary search概念轉換成Code</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * @return Retrun index of number in array.
</span><span class='line'> * If number not found in array return false.
</span><span class='line'> */
</span><span class='line'>- (NSNumber *)binarySearchIndexInArray:(NSArray &lt;NSNumber *&gt;*)array forNumber:(NSNumber *)number leftRange:(NSInteger)left rightRange:(NSInteger)right {
</span><span class='line'>    
</span><span class='line'>    if (left &gt; right) {
</span><span class='line'>        return [NSNumber numberWithBool:false];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSInteger midIndex = (left+right)/2;
</span><span class='line'>    NSNumber* mid = array[midIndex];
</span><span class='line'>    
</span><span class='line'>    if (number.floatValue &gt; mid.floatValue) { // 對切的右邊
</span><span class='line'>        return [self binarySearchIndexInArray:array forNumber:number leftRange:midIndex+1 rightRange:right];
</span><span class='line'>    }else if (number.floatValue &lt; mid.floatValue){ // 對切的左邊
</span><span class='line'>        return [self binarySearchIndexInArray:array forNumber:number leftRange:left rightRange:midIndex-1];
</span><span class='line'>    }else{ // equal，找到了
</span><span class='line'>        return  [NSNumber numberWithInteger:midIndex];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>關於搜尋</h2>

<p>這個搜尋法的前提是你的數列要幾經排序好了。這個前置條件才讓我發現我之前一直以為搜尋是有什麼神奇的方法，能夠在一個大數列裡面找到target的位置，現在接觸演算法就理解現實運作方法是先排序之後再用方法搜尋的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/09/objc-quick-sort/">QuickSort與Obj-C</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-11-09T10:24:20+08:00" pubdate data-updated="true">Nov 9<sup>th</sup>, 2016</time>
        
           | <a href="/blog/2016/11/09/objc-quick-sort/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2016/11/09/objc-quick-sort/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Qucik Sort概念</h2>

<p>第一次看到快速排序的許多介紹，可能第一時間腦袋轉不太過來，因為網路介紹常常把虛擬碼翻成步驟，直接敘述，所以腦袋普通像我就會沒辦法意會為什麼要做這個動作。比如後面會提到的In-Place版本交換這個動作就常常不知為何而做。這裡有個<a href="https://www.youtube.com/watch?v=aQiWF4E8flQ">影片</a>是從很高層次想法上去解釋Quick Sort，個人看了之後再想想虛擬碼，也就豁然開朗了。</p>

<h2>Qucik Sort概念轉換成Code</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)quickSortUseExtraMemoryWithData:(NSArray *)data {
</span><span class='line'>
</span><span class='line'>    if (data.count &lt;= 1) { // 到底部了, 不需要排序, 直接回傳
</span><span class='line'>        return data;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    int random = arc4random() % data.count;  // 隨機取用某index當pivot，避免比如排序已經排好的陣列，每次都取index0，會造成時間複雜度O(N^2)，worst case
</span><span class='line'>    NSNumber *pivot = data[random];
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *less = [[NSMutableArray alloc]init];
</span><span class='line'>    NSMutableArray *greater = [[NSMutableArray alloc]init];
</span><span class='line'>    
</span><span class='line'>    for (int i=1; i&lt;=data.count-1; i++ ) {
</span><span class='line'>        if ([(NSNumber *)data[i]floatValue] &gt;= [pivot floatValue]) {
</span><span class='line'>            [greater addObject:data[i]];
</span><span class='line'>        }else {
</span><span class='line'>            [less addObject:data[i]];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *result = [[NSMutableArray alloc]init];
</span><span class='line'>    [result addObjectsFromArray:[self quickSortUseExtraMemoryWithData:less]];
</span><span class='line'>    [result addObject:pivot];
</span><span class='line'>    [result addObjectsFromArray:[self quickSortUseExtraMemoryWithData:greater]];
</span><span class='line'>    
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果常寫有支援記憶體管理語言比如Java或ARC版Obj-C的人可能會直覺寫出這個版本，因為在這幾個語言裡其實常常不用太管記憶體使用量太多這個問題，除非是<code>UIImage</code>等大型物件沒有釋放，不然常常遇到比如<code>NSArray</code>分割其實也就是再開兩個NSArray去存就好了。</p>

<p>上面這個實作方法每次都新開<code>NSArray</code>去存放分割後的子Array，而Quick Sort比Merge Sort好的地方在於它可以改用稱作In-Place的方法，只在同一個陣列做交換，可以避免運用消耗多餘的記憶體空間，參考文獻也寫說實務上也可以增加演算法的效率。</p>

<h2>Qucik Sort In-Place 版本</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSMutableArray *)quickSortInPlaceWithData:(NSMutableArray &lt;NSNumber *&gt;*)data leftIndex:(NSInteger)left rightIndex:(NSInteger)right{
</span><span class='line'>    // 使用in-place法，操作同一個陣列，避免額外消耗多餘記憶體，硬體限制嚴格的環境下使用
</span><span class='line'>    
</span><span class='line'>    if (left &gt; right) { // 底部。代表上一層遞迴切出來，這個sub-array已經只有一個元素，就不用排列了，'這個元素也會是已經就定位的'。
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSNumber *pivot = data[right];
</span><span class='line'>    
</span><span class='line'>    NSInteger processIndexAKAWall = left;
</span><span class='line'>    [data exchangeObjectAtIndex:right withObjectAtIndex:right];// 把pivot移到最後面
</span><span class='line'>    for (int i=(int)left; i&lt;right; i++ ) { // left ... right-1
</span><span class='line'>        if ([data[i]floatValue] &lt; [pivot floatValue]) {
</span><span class='line'>            [data exchangeObjectAtIndex:processIndexAKAWall withObjectAtIndex:i];// 擺到牆的右邊
</span><span class='line'>            processIndexAKAWall = processIndexAKAWall + 1;// 牆往前
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    [data exchangeObjectAtIndex:processIndexAKAWall withObjectAtIndex:right];// 把pivot移到牆的右邊。這個pivot目前已經在正確的index上了。
</span><span class='line'>    
</span><span class='line'>    // 切兩段
</span><span class='line'>    // start by left, end by processIndexAKAWall - 1
</span><span class='line'>    // start by processIndexAKAWall + 1, end by right
</span><span class='line'>    [self quickSortInPlaceWithData:data leftIndex:left rightIndex:processIndexAKAWall - 1];
</span><span class='line'>    [self quickSortInPlaceWithData:data leftIndex:processIndexAKAWall + 1 rightIndex:right];
</span><span class='line'>    
</span><span class='line'>    return data;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>更好用的呼叫方式</h2>

<p>平均空間複雜度更好的In-Place版本，因為只有<code>NSMutableArray</code>可以交換item，所以如果傳入值是是<code>NSArray</code>則呼叫的時候要寫成以下方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray *result = [self quickSortInPlaceWithData:[data mutableCopy] leftIndex:0 rightIndex:data.count-1];</span></code></pre></td></tr></table></div></figure>


<p>而為了可以讓<code>NSArray</code>可以使用，也方便之後做成<code>NSArray</code>的<code>Category</code>，就可以改寫成以下這種較為方便別人使用的方式，因為別人不一定知道Left與Right，也不需要懂實作細節情況下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)quickSort:(NSArray *)data {
</span><span class='line'>    return [self quickSortInPlaceWithData:[data mutableCopy]  leftIndex:0 rightIndex:data.count-1];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/07/objc-merge-sort-category-oop/">MergeSort與Obj-C外加Category與OOP</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-11-07T00:18:53+08:00" pubdate data-updated="true">Nov 7<sup>th</sup>, 2016</time>
        
           | <a href="/blog/2016/11/07/objc-merge-sort-category-oop/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2016/11/07/objc-merge-sort-category-oop/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Merge Sort概念</h2>

<p>跟我一樣原本不知道Merge Sort是什麼碗糕的可以去這個<a href="https://www.youtube.com/watch?v=mzjjRPdH9Jw">影片</a>，這裡有可愛北一女的實際示範，中文的呦。如果英文好那我也是更推薦去看英文的，那資源又更多了。</p>

<h2>Merge Sort概念轉換成Code</h2>

<p>在懂了Merge Sort概念之後，如果對於如何把想法轉換成程式碼沒什麼感覺，可以看一段<a href="https://www.youtube.com/watch?v=es2T6KY45cA&amp;index=3&amp;list=PL2aHrV9pFqNRS2b2XX2BvgQIPKh72xREP">影片</a>，這段影片大概就是程式碼影片化後實際運作的樣子。</p>

<p>Merge Sort有分Recursive跟For loop兩種，但看完影片直覺就是用Recursive比較好做。這是因為你看Merge Sort其實是把一個大問題分成小問題，小問題再分成更小的問題，直到把問題切割成最小單元，再返回來把前一次的結果餵給上一層，之後一層一層的解回去。這是很典型的遞迴場景。
NSMutableArray
上面的問題解決思路在演算法裡面叫做Divide and Conquer，蠻傳神的解釋，把問題分解後在各個擊破。</p>

<h2>Objective-c Implement</h2>

<ul>
<li>Input為一個NSArray，裡面包含N個NSNumber，NSNumber可以為Int或Flot。</li>
<li>Output為一個把Input Array裡面的N個NSNumber由小排序到大的NSArray。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)mergeSortWithData:(NSArray *)data {
</span><span class='line'>    
</span><span class='line'>    if (data.count == 1) {
</span><span class='line'>        // div done here
</span><span class='line'>        // 這裡已經把問題分解成最小單位了，所以就告一段落
</span><span class='line'>        return data;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSInteger divLength = data.count/2;
</span><span class='line'>    NSArray *left = [data subarrayWithRange:NSMakeRange(0, divLength)];
</span><span class='line'>    NSArray *rigth = [data subarrayWithRange:NSMakeRange(divLength, data.count-divLength)];
</span><span class='line'>    
</span><span class='line'>    NSArray&lt;NSNumber*&gt; *mergeArrayA = [self mergeSortWithData:left];
</span><span class='line'>    NSArray&lt;NSNumber*&gt; *mergeArrayB = [self mergeSortWithData:rigth];
</span><span class='line'>    
</span><span class='line'>    NSInteger headOfMergeArrayA = 0;
</span><span class='line'>    NSInteger headOfMergeArrayB = 0;
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *resultArray = [[NSMutableArray alloc]initWithCapacity:mergeArrayA.count+mergeArrayB.count];
</span><span class='line'>    
</span><span class='line'>    Boolean control = true;
</span><span class='line'>    while (control) {
</span><span class='line'>        
</span><span class='line'>        if (headOfMergeArrayA == mergeArrayA.count) {
</span><span class='line'>            //MergeArrayA沒東西了
</span><span class='line'>            //把剩餘的MergeArrayB直接append到resultArray後面
</span><span class='line'>            [resultArray addObjectsFromArray:[mergeArrayB subarrayWithRange:NSMakeRange(headOfMergeArrayB, mergeArrayB.count-headOfMergeArrayB)]];
</span><span class='line'>            control = false;
</span><span class='line'>            break;
</span><span class='line'>        }else if(headOfMergeArrayB == mergeArrayB.count){
</span><span class='line'>            [resultArray addObjectsFromArray:[mergeArrayA subarrayWithRange:NSMakeRange(headOfMergeArrayA, mergeArrayA.count-headOfMergeArrayA)]];
</span><span class='line'>            control = false;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        if ([mergeArrayA[headOfMergeArrayA]floatValue] &gt; [mergeArrayB[headOfMergeArrayB]floatValue]) {
</span><span class='line'>            [resultArray addObject:mergeArrayB[headOfMergeArrayB]];
</span><span class='line'>            headOfMergeArrayB = headOfMergeArrayB + 1;
</span><span class='line'>        }else{
</span><span class='line'>            [resultArray addObject:mergeArrayA[headOfMergeArrayA]];
</span><span class='line'>            headOfMergeArrayA = headOfMergeArrayA + 1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return resultArray;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Do more &ndash; Free Function與Method</h2>

<p>可以看到<code>mergeSortWithData</code>是一個Function，但我自己Obj-C軟體實作的Coding style上如果一個Function的Input有指定要是某個Class，比如這裡就是指定<code>NSArray</code>，那這時候採用Method較好。</p>

<p>但通常很少情況會不指定Input的Clsas，所以實務上會盡量少用Free Function，附帶的好處是可以減少一堆Function散落在專案裡面，也可以盡量DRY（Don&rsquo;t repeat yourself）。</p>

<p>當然，不要過度強調DRY，因為這關係到切架構與抽象化整體的規劃能力，抽象的不好那是會用弄越糟的，但至少在這個簡單的Case裡Merge Sort做成Method絕對是make sense的。</p>

<p>這裡可以練習把Merge Sort用<code>Category</code>的方式做成<code>NSArray</code>的Method。基礎OOP，把一些地方改成<code>Self</code>就可以了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/24/iap-payment-model-design/">In-App-Purchase交易模組設計</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-08-24T23:30:18+08:00" pubdate data-updated="true">Aug 24<sup>th</sup>, 2016</time>
        
           | <a href="/blog/2016/08/24/iap-payment-model-design/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2016/08/24/iap-payment-model-design/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>網路上很多介紹如何運用<code>StoreKit</code>裡面的API在iOS上付款的文章，但實務上因為<code>In-App-Purchase</code>是程式裡面需要密集配合業務需求的部分，如果沒有一個良好抽象化的設計，在高可維護性與彈性，可擴展能力下功夫，一旦業務需求一複雜或反覆迭代更改，就會讓IAP相關的邏輯變得難以修改與維護。</p>

<p>以上原因，所以如何在APP中設計一套可維護可擴展易整合的IAP架構，是開發大型APP與進階開發者應該關心的議題。接下來的文章把IAP付款架構有關執行交易與交易結果處理的這部分，抽象成TNStoreObserver類別。</p>

<h2>StoreObserver</h2>

<p>付款流程是APP根據一組定義在iTunesConnect的商品ID，向Apple Server請求對應的<code>SKPayment</code>物件，裡面包含了Localization的商品名稱與價錢，把這個想成一個商品。而一旦把這個<code>SKPayment</code>物件放到由系統維護的<code>SKPaymentQueue</code>時，這時候就開始進入按指紋，輸入iTunes Store帳密的程序。</p>

<p>而<code>StoreKit</code>說明，當<code>SKPayment</code>加入到<code>SKPaymentQueue</code>後，開發者需要實作一個adopt<code>SKPaymentTransactionObserver</code>protocol的物件，並加入到<code>SKPaymentQueue</code>裡。之後這個Observer就是負責處理各種交易結果。比如成功時就要開啟對應的功能等。</p>

<p>所以這個Class就取名叫StoreObserver，職責是實作<code>SKPaymentTransactionObserver</code>protocol，處理交易完成的後續行為。並負責與<code>SKPaymentQueue</code>互動，比如購買，取回過去的購買紀錄。最後可方便的在任何地方發動購買，然後在需要的地方容易接收到結果。</p>

<p>基於以上需求，開去構思這個模組。</p>

<p>先處理交易的部分，這就是單純與StoreKit串接。以下兩個Public方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 購買SKProduct
</span><span class='line'>// Create and add a payment request to the payment queue
</span><span class='line'>-(void)buy:(SKProduct *)product
</span><span class='line'>{
</span><span class='line'>    SKMutablePayment *payment = [SKMutablePayment paymentWithProduct:product];
</span><span class='line'>  [[SKPaymentQueue defaultQueue] addPayment:payment];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 取回過去完成交易的非消耗品購買與自動續訂紀錄
</span><span class='line'>-(void)restore
</span><span class='line'>{
</span><span class='line'>    [[SKPaymentQueue defaultQueue] restoreCompletedTransactions];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>實作上會把這個<code>StoreObserver</code>做成<code>Singleton</code>，因為APP裡面可能會有許多頁面允許付款，只要<code>[[StoreObserver sharedInstance] buy:product];</code>就可以購買商品。然後因應上面的<code>restore</code>方法，這裡需要一個<code>NSArray</code>來裝取回的商品們，命名為<code>productsRestored</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (StoreObserver *)sharedInstance
</span><span class='line'>{
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    static StoreObserver * storeObserverSharedInstance;
</span><span class='line'>    
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        storeObserverSharedInstance = [[StoreObserver alloc] init];
</span><span class='line'>    });
</span><span class='line'>    return storeObserverSharedInstance;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>- (instancetype)init
</span><span class='line'>{
</span><span class='line'>  self = [super init];
</span><span class='line'>  if (self != nil)
</span><span class='line'>    {
</span><span class='line'>        _productsRestored = [[NSMutableArray alloc] initWithCapacity:0];
</span><span class='line'>    }
</span><span class='line'>  return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>這邊重要的來了，如果程式的某個地方呼叫了<code>StoreObserver</code>的<code>buy</code>發法，之後<code>StoreObserver</code>收到交易完成的資訊，而APP裡面可能會有很多地方因為這個交易而產生UI上的變化，比如買了一部影片，影片要開始播放，影片櫃需要新增新影片，會員的購買紀律需要增加一筆。該怎麼通知那麼多地方？這裡用了<code>NSNotificationCenter</code>。</p>

<p>為什麼呢？因為在上述一對多的狀況下，<code>StoreObserver</code>會被設計成它不關心那些畫面或地方需要這些訊息。但它會把資料準備好，接著廣播。</p>

<p>當通知的人不關心他會通知到誰，但可能需要被通知的人很多時，<code>NSNotificationCenter</code>機制就派上用場了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString * const TNIAPPurchaseNotification = @"TNIAPPurchaseNotification";</span></code></pre></td></tr></table></div></figure>


<p>再來是讓接收廣播的地方容易做處理。在這個Class裡面我們設置三個Property，<code>status</code>，<code>message</code>和<code>purchasedID</code>。當這個Class實作<code>SKPaymentTransactionObserver</code>時，根據收到的資訊做整理，讓接收的人可以很方便利用交易結果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_ENUM(NSInteger, TNIAPPurchaseNotificationStatus)
</span><span class='line'>{
</span><span class='line'>    TNIAPPurchaseFailed, // Indicate that the purchase was unsuccessful
</span><span class='line'>    TNIAPPurchaseSucceeded, // Indicate that the purchase was successful
</span><span class='line'>    TNIAPRestoredFailed, // Indicate that restore products was unsuccessful
</span><span class='line'>    TNIAPRestoredSucceeded // Indicate that restore products was successful
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>@property (nonatomic) TNIAPPurchaseNotificationStatus status;
</span><span class='line'>@property (nonatomic, copy) NSString *purchasedID;
</span><span class='line'>@property (nonatomic, copy) NSString *message;</span></code></pre></td></tr></table></div></figure>


<p>比如當我們實作的<code>SKPaymentTransactionObserver</code>方法被<code>SKPaymentQueue</code>呼叫時，整理一下再POST Notification出去</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Called when an error occur while restoring purchases. Notify the user about the error.
</span><span class='line'>- (void)paymentQueue:(SKPaymentQueue *)queue restoreCompletedTransactionsFailedWithError:(NSError *)error
</span><span class='line'>{
</span><span class='line'>    if (error.code != SKErrorPaymentCancelled)
</span><span class='line'>    {
</span><span class='line'>        self.status = IAPRestoredFailed;
</span><span class='line'>        self.message = error.localizedDescription;
</span><span class='line'>        [[NSNotificationCenter defaultCenter] postNotificationName:TNIAPPurchaseNotification object:self];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>實際運作</h2>

<p>這邊我們不考慮要怎麼取得到SKPayment物件，因為這部分邏輯不在<code>StoreObserver</code>負責範圍內。</p>

<h3>在任何地方容易的發動購買</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SKProduct *product = (SKProduct *)productRequestResponse[indexPath.row];
</span><span class='line'>        // Attempt to purchase the tapped product
</span><span class='line'>        [[TNStoreObserver sharedInstance] buy:product];</span></code></pre></td></tr></table></div></figure>


<h3>在需要的地方容易收到並做處理</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[NSNotificationCenter defaultCenter] addObserver:self
</span><span class='line'>                                             selector:@selector(handlePurchasesNotification:)
</span><span class='line'>                                                 name:TNIAPPurchaseNotification
</span><span class='line'>                                               object:[StoreObserver sharedInstance]];
</span><span class='line'>
</span><span class='line'>// Update the UI according to the purchase request notification result
</span><span class='line'>-(void)handlePurchasesNotification:(NSNotification *)notification
</span><span class='line'>{
</span><span class='line'>    StoreObserver *purchasesNotification = (StoreObserver *)notification.object;
</span><span class='line'>    
</span><span class='line'>    IAPPurchaseNotificationStatus status = (IAPPurchaseNotificationStatus)purchasesNotification.status;
</span><span class='line'>    NSString *message = purchasesNotification.message;
</span><span class='line'>    NSString *purchasedID = purchasesNotification.purchasedID;
</span><span class='line'>   
</span><span class='line'>
</span><span class='line'>  switch (status)
</span><span class='line'>    {
</span><span class='line'>        case IAPPurchaseFailed:
</span><span class='line'>            //購買失敗...
</span><span class='line'>          break;
</span><span class='line'>            
</span><span class='line'>        case IAPDownloadSucceeded:
</span><span class='line'>        {
</span><span class='line'>            //購買成功...
</span><span class='line'>        }
</span><span class='line'>          break;
</span><span class='line'>        
</span><span class='line'>        case IAPRestoredSucceeded:
</span><span class='line'>        {
</span><span class='line'>            //回復成功...
</span><span class='line'>        }
</span><span class='line'>            break;
</span><span class='line'>            
</span><span class='line'>        case IAPRestoredFailed:
</span><span class='line'>            //回復失敗...
</span><span class='line'>            break;
</span><span class='line'>  } 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/11/ios-view-advanced/">從零到穩固的基礎 - 談iOS刻畫UI</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-08-11T22:02:46+08:00" pubdate data-updated="true">Aug 11<sup>th</sup>, 2016</time>
        
           | <a href="/blog/2016/08/11/ios-view-advanced/#disqus_thread"
             data-disqus-identifier="http://sah.tw/blog/2016/08/11/ios-view-advanced/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>MVVM是iOS開發近來熱門的開發架構，最近工作上不停用到這個架構去建立各種頁面，對於如何從零開始架構出一個方便開發與維護的MVVM架構有些實作上總結出的Tips或稱為想法在，這裡記錄下來與回顧。</p>

<p>系列第一篇會先從MVVM裡面的View開始講，通常這也是我開發的第一也是很重要的步驟，這裡一開始沒規劃好浪費的時間絕對是最多的，因為方向就錯了麻。</p>

<h2>看UI圖然後先想想</h2>

<p>第一步當然就是看著UI出好的圖，然後想想這個畫面上會用的什麼<code>UIKit</code>的控件。大部分不外乎是<code>TableView</code>, <code>CollectionView</code>, <code>PageView</code>，互相搭配即可組出框架。某些例外比如登入登出註冊頁面則通常就會一張空白<code>View</code>自己拉畫面，不太用到上面提到的控件。</p>

<p>真的有問題比如需要重新打造一個控件，或不好實作，卡到時間等，都在這裡即時反應給UI是最好的。不會先做下去遇到問題卡住再來溝通，這樣事倍功半真的也很浪費時間。</p>

<h2>先大致上命名好</h2>

<p>曾經有看過程式設計裡面在資深開發人員裡排名第一的難題是命名。這是因為如果一開始沒有想好階層式的命名方式，等到架構一大你就會開始需要在腦袋裡面Dump一堆記憶體來存這些Name的意義，久了也一定會忘記。</p>

<p>比如常見的新聞頁面</p>

<p><img src="http://sah.tw/images/2016-08-11-ios-view-advanced.png" alt="YahooNews" /></p>

<p>這個頁面大致需要下面幾個控件:</p>

<ol>
<li>主要<code>ViewController</code></li>
<li>一個<code>CollectionView</code>來當Indicator，顯示有那些類別</li>
<li>一個<code>PageController</code>來橫向翻頁在不同類別的新聞頁面</li>
<li>多個<code>TableView</code>拿來顯示新聞</li>
</ol>


<p>那在命名上就要先大致想好：</p>

<ol>
<li><code>SHReaderViewController</code></li>
<li><code>SHReaderCategoryIndicatorViewController</code> &ndash; <code>SHReaderCategoryIndicatorCell</code></li>
<li><code>SHReaderPageViewController</code></li>
<li><code>SHReaderNewsViewController</code> &ndash; <code>SHReaderNewsCell</code></li>
</ol>


<p>只要名字的Prefix按照大方向一樣，階層想好定下來後，不管是要新增Coustom Class，或是要在<code>Storyboard</code>上標註對應的<code>Storyboard Identifier</code>都很方便，之後再開發與維護上會因為也脈絡可循的命名而容易許多。</p>

<h2>多使用StackView</h2>

<p>在iOS9加入<code>StackView</code>之後，整個畫面裡面<code>Autolayout</code>所需要的<code>Constraints</code>大幅的減少很多，事實上官方也建議最好<code>Autolayout</code>任何畫面可以考慮直接用<code>StackView</code>開始。</p>

<p><code>StackView</code>的強項在於可以定義一個母區塊，讓裡面的<code>SubView</code>能Depend在母區塊的邊界上設定<code>Constraints</code>與做<code>Autolayout</code>，同時也限制這裡面的<code>StackView</code>裡的<code>SubView</code>改動不會影響到<code>StackView</code>之外的其他<code>View</code>。</p>

<p>在沒有<code>StackView</code>之前只有一個<code>RootView</code>要給整個畫面上一堆<code>SubView</code>當做參照，這樣在設計<code>Autolayout</code>上往往牽一髮動全身，一個<code>SubView</code>的更改常常就會連帶影響一大推其他的<code>View</code>。</p>

<h2>用Storyboard Reference切割不同功能的畫面</h2>

<p>比如<code>Tabbar</code>分出來的全部連到<code>Storyboard Reference</code>，或多次在不同地方會單獨<code>M  odel</code>出來的畫面要拆分出來。這樣一個團隊才可以同時協作開發多個頁面，解決了<code>Storyboard</code>一開始被大家詬病的<code>Git</code>協作問題。</p>

<h2>還有一些比較瑣碎的Tips</h2>

<h3>適時用Xib搭配Storyboard</h3>

<p>當我們有時候要自製一個小控件比如<code>Segment Control</code>，裡面的<code>Cell</code>便可以用xib。掌握住<code>initWithCoder</code>用來再<code>Storyboard</code>載入，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="no">If</span> <span class="n">you</span> <span class="n">are</span> <span class="n">loading</span> <span class="n">it</span> <span class="n">from</span> <span class="n">a</span> <span class="n">nib</span> <span class="n">file</span> <span class="p">(</span><span class="ow">or</span> <span class="n">a</span> <span class="n">storyboard</span><span class="p">),</span> <span class="ss">initWithCoder</span><span class="p">:</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="ss">initWithCoder</span><span class="p">:(</span><span class="no">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="n">aDecoder</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="o">[</span><span class="k">super</span> <span class="ss">initWithCoder</span><span class="p">:</span><span class="n">aDecoder</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">[</span><span class="nb">self</span> <span class="ss">addSubview</span><span class="p">:</span><span class="o">[[[</span><span class="no">NSBundle</span> <span class="n">mainBundle</span><span class="o">]</span> <span class="ss">loadNibNamed</span><span class="p">:</span><span class="no">NSStringFromClass</span><span class="p">(</span><span class="o">[</span><span class="nb">self</span> <span class="n">class</span><span class="o">]</span><span class="p">)</span> <span class="ss">owner</span><span class="p">:</span><span class="nb">self</span> <span class="ss">options</span><span class="p">:</span><span class="kp">nil</span><span class="o">]</span> <span class="ss">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="o">]]</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>initWithFrame</code>則是有時候不得已用Code的方式呼叫：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">-</span> <span class="p">(</span><span class="nb">id</span><span class="p">)</span><span class="ss">initWithFrame</span><span class="p">:(</span><span class="no">CGRect</span><span class="p">)</span><span class="n">frame</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="o">[</span><span class="k">super</span> <span class="ss">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="sr">//</span> <span class="no">Initialization</span> <span class="n">code</span>
</span><span class='line'>        <span class="nb">self</span><span class="o">.</span><span class="n">autoresizesSubviews</span> <span class="o">=</span> <span class="no">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>並且記得如果用Code呼叫要<code>Frame</code>，要在<code>viewDidAppear</code>這裡面做，因為根據<code>ViewController</code>這裡才是<code>Frame</code>經過<code>Autolayout</code>等計算後真正確定的地方。</p>

<h3>利用SizeClass</h3>

<p>比如轉向的需求，利用<code>Storyboard</code>的<code>SizeClass</code>在不同情境下就可以很輕易漂亮的適配出你要的螢幕Layout，比如影片橫幅要佔滿全螢幕等。</p>

<h2>Then&hellip;</h2>

<p>其實在Xcode裡面刻畫環境真的是很享受的過程，當你刻畫出的UI在<code>Storyboard</code>上跟UI出的圖一樣時，那樣的成就感很高。尤其Apple近幾年推出的<code>Autolayout</code>跟<code>SizeClass</code>其實都走在很前端的地方，給開發者很大的彈性與方便。</p>

<p>這裡也推薦這個網站Zeplin，我現在配合的設計師可以很方便地更新圖給大家，上面尺寸也都可以標註到很細，甚至這個網站還有Mac的APP，裡面有個特異功能是可以把素材匯進到專案的<code>Assets.xcassets</code>真的很棒！</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - 施安宏 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'mrshih';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
