<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MR SHIH]]></title>
  <link href="http://sah.tw/atom.xml" rel="self"/>
  <link href="http://sah.tw/"/>
  <updated>2017-02-13T16:12:13+08:00</updated>
  <id>http://sah.tw/</id>
  <author>
    <name><![CDATA[施安宏]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker 運用Volume達成資料分離]]></title>
    <link href="http://sah.tw/blog/2017/02/13/docker-volume/"/>
    <updated>2017-02-13T14:23:05+08:00</updated>
    <id>http://sah.tw/blog/2017/02/13/docker-volume</id>
    <content type="html"><![CDATA[<h2>為什麼要用volume？</h2>

<p>Docker的Container有個重要的原則是不儲存資料。為什麼呢？比如你做一個Web Service的Image，你把NPM,前端分流Nginx等軟體都安裝好了，這時候要把網頁的檔案放進去，一種做法是在<code>Dockerfile</code>裡面用<code>COPY</code>把網頁檔給複製進Image裡面，然後再Run起來。</p>

<p>可是這種把<code>資料</code>存在Image裡的做法會帶來許多問題，我如果改一行Code我不就要重新Build或新Commit一個Image嗎？我如果有好多個網站要跑在不同的Container上，我不就要做好多個Image？如果是DB的Image，把<code>資料</code>放在Image裡面，那不就隨著時間過去Image就要一直更新了?</p>

<p>所以在製作Image上，常見的best practice是把執行環境打包成Image，而時常會修改的檔案比如網頁檔案或資料庫檔案這些<code>資料</code>就與Image分開，放在外掛上去的volume，與Image分離。這樣就可解決上面所提及的問題。</p>

<p>底下我們就以網頁服務常見的/var/www資料夾與資料庫常見的/var/lib/mysql為例，說明怎麼把這兩個存<code>資料</code>的地方給另外存在volume上。</p>

<h2>製作data volume container</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker create -v absolute/path/to/host/dir:/var/lib/mysql --name dbdata mysql   //產生一個container, 掛載host資料夾(absolute/path/to/host/dir)到container的/var/lib/mysql</span></code></pre></td></tr></table></div></figure>


<p>這裡的-v用法就是用來掛載volume的，去mount一個host資料夾為container的data volume。並且把這個container指名為dbdata，這種container又稱作為<code>data volume container</code>。</p>

<p>這種container特別在於本身只是用來記載那個host資料夾對應mount到container的那個資料夾，所以container本身是不用啟動(run)的。</p>

<p>PS. 如果Host的dir沒有指定，則docker會在系統的某個陰暗角落建立一個新的資料夾。可以用<code>docker inspect container-id</code>指令回傳結果裡key<code>Mounts</code>的Dictionary裡找到那個陰暗角落。</p>

<h2>使用data volume container</h2>

<p>有了data volume container後，只要以後在run container時透過<code>--volumes-from</code>參數，就可以直接把指定的<code>data volume container</code>的volume給掛載進來。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run --name=mysqldb -d -p 3306:3306 --volumes-from= dbdata mysql</span></code></pre></td></tr></table></div></figure>


<p>這時候新產生名為mysqldb的container，cd到<code>/var/lib/mysql</code>就會發現與host的<code>absolute/path/to/host/dir</code>資料夾是連動的，也就是mount再一起了。</p>

<p>舉個實用情境，假如資料庫版本要升級，只要在<code>Dockerfile</code>裡面升級資料庫版本，然後把新的container啟動時掛載dbdata，資料就還是一樣。而如果當初沒有把<code>資料</code>從Image分離出來，是要不原本DB的資料給匯出，再匯入新Image，非常麻煩，而不這麼做DB的紀錄就消失不見囉。</p>

<p>這裡的效果也就是<a href="https://docs.docker.com/engine/tutorials/dockervolumes/">官方介紹</a>的volume主要用途，把<code>資料</code>與container分開，達到data persistence的目的。</p>

<p><code>Data volumes are designed to persist data, independent of the container’s life cycle.</code></p>

<h2>同理可證的Web Service</h2>

<p>一但建構好基本環境，比如NPM, PM2, Nginx&hellip;etc，打包成一個Image後創建Container，以後Run這個Container只要搭配以下參數，就可以在本地修改，然後在container裡面實際測試了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-v absolute/path/to/host/web/dir/project:/var/www/project</span></code></pre></td></tr></table></div></figure>


<h2>FYI</h2>

<ul>
<li><a href="https://docs.docker.com/engine/tutorials/dockervolumes/">https://docs.docker.com/engine/tutorials/dockervolumes/</a></li>
<li><a href="https://jiajially.gitbooks.io/dockerguide/content/chapter_fastlearn/docker_run/data_manager.html">https://jiajially.gitbooks.io/dockerguide/content/chapter_fastlearn/docker_run/data_manager.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker 從Image到Service]]></title>
    <link href="http://sah.tw/blog/2017/02/09/docker101/"/>
    <updated>2017-02-09T13:22:36+08:00</updated>
    <id>http://sah.tw/blog/2017/02/09/docker101</id>
    <content type="html"><![CDATA[<h2>本身工作偏開發，為何要了解Docker？</h2>

<p>最近Micro service火紅，大型服務被切成一個一個小模組，減少彼此耦合，個別跑在各自container上，方便重複部署，且彼此互相用Rest API或socket溝通。這樣帶來的好處在於可以在開發上減少後續迭代的困難，減少維運的難度，增加系統穩定性。</p>

<p>但要獲得這些好處，軟體在最初開始設計架構的階段就要拆分服務，一開始設計不好之後就算有docker工具那也只是把所有服務丟到同一個Container上，沒有辦法發揮docker切割服務的優勢。</p>

<p>所以想成為架構師，當然不能不了解這個工具。而從程式開發上來看，能夠把CI Keep in mind，有新Commit Push到develop branch，CI Server就自動執行下面步驟</p>

<ol>
<li>打包新的Image</li>
<li>產生Container</li>
<li>執行Service</li>
<li>Run Test Code&hellip;</li>
</ol>


<p>能夠協助開發者確保最終程式碼在Production環境是可以正常運行，有問題可以立即發現與處理。</p>

<p>Docker對比傳統VM優點在於所消耗資源很小，啟動速度很快，並且兼具傳統VM打包成Image擋可以Anywhere都快速建立起一樣的Service等優點。</p>

<p>這篇文章主要就以上面幾點依序從包含如何製作Image，產生Container，利用Container啟動我們要的Service，最後如何匯出部署到另一台機器等一系列記錄下來。</p>

<h2>Dockerfile與Base Image</h2>

<p>要導入的Service是由三個部分組成</p>

<ol>
<li>Node.js專案，用Express作為Route Framework，為業務邏輯層負責API JSON的輸出</li>
<li>Node.js專案，用Express作為Route Framework，使用Bootstrap來包含View的後台操作介面</li>
<li>MySQL Instance</li>
</ol>


<p>之前做法是把Node.js專案都放在同台Server，但因爲HA需要，所以也有一台Hot standby的實體機並排在HAProxy下。這裡帶來第一個問題是當要重新build環境時靠Install Guide手動安裝很不方便，解決方法便是用<code>Dockerfile</code>，把Install Guide所需的環境與步驟打包成一個Image。</p>

<p>1&amp;2專案相同部分是<code>Node.js專案，用Express作為Route Framework</code>，所以可以Build一個Base Image來當基底環境，之後只要分別把<code>/var/www</code>置換成對應的專案檔即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM centos:7 // 指定CentOS
</span><span class='line'>MAINTAINER daan.shih@gmail.com
</span><span class='line'>RUN yum install -y epel-release // -y避免互動輸入
</span><span class='line'>RUN yum install -y nodejs
</span><span class='line'>RUN yum install -y npm
</span><span class='line'>RUN npm install pm2 -g
</span><span class='line'>RUN mkdir /var/www/
</span><span class='line'>WORKDIR /var/www/</span></code></pre></td></tr></table></div></figure>


<p>有了Dockerfile後就可以Build Image了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker build -f /path/to/dockerfile ./</span></code></pre></td></tr></table></div></figure>


<p>之後會得到一個Image ID，因為是只安裝npm基底就取名為npm-ready</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker tag [Image ID] npm-ready</span></code></pre></td></tr></table></div></figure>


<p>現在打<code>docker images</code>應該可以看到類似<code>npm-ready               latest              43c671f848fd        22 hours ago        405.6 MB</code>的資訊</p>

<h2>以Base Image為底，加入express專案檔</h2>

<p>這時候我們已經有一個Image檔，包含npm與必須的tools，只缺express專案檔。所以接下來就以<code>FROM</code>指令，指定以<code>npm-ready:latest</code>為底，用<code>COPY</code>指令把我們需要的專案檔複製到Image中。</p>

<p>這裡要注意第三行的<code>PSControlCenter/</code>這個目錄必須與Dockerfile同一個目錄（<code>docker build</code>後面會加上的path我們是打./），不然會出現找不到此目錄。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM npm-ready:latest
</span><span class='line'>MAINTAINER daan.shih@gmail.com
</span><span class='line'>COPY ControlCenter/ /var/www/</span></code></pre></td></tr></table></div></figure>


<p>得到新Image ID後幫它補上名字方便識別</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker tag [Image ID] control-center</span></code></pre></td></tr></table></div></figure>


<h3>Image to Container</h3>

<p>至此我們已經有一個包含全部所需要檔案的Image檔<code>control-center</code>了。現在只需要利用Image去產生一個Container，並且執行這個Container就行了。</p>

<p>本來產生<code>create</code>與執行<code>start</code>是兩個指令，這裡可以用<code>run</code>來代表連續執行上面兩個指令。類似git裡面<code>pull</code>是連續執行<code>fetch</code>和<code>merge</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -t -i -p 9453:3000 [Image ID] /bin/bash</span></code></pre></td></tr></table></div></figure>


<p>這裡要注意的是<code>-p</code>，每個運行中的container的網路環境與host是完全分離的，所以我們要從外部去訪問container，就要用這個指令來指定port的相依關係。</p>

<p>這個例子裡我們在host輸入127.0.0.1:9453就會訪問到container的3000 port。</p>

<p>建立完container後，這時可以透過下面指令拿到Container ID</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker ps -a // -a會列出所有container(包含停止)</span></code></pre></td></tr></table></div></figure>


<p>運行container後，想再得到運行狀態中的container的bash shell可執行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker exec -it [container-id] bash</span></code></pre></td></tr></table></div></figure>


<p>exec指令就是對該運行中的container下達指令。</p>

<h2>Run Service</h2>

<p>到這裡我們已經利用Image去產生Container，並起啟動了Container，指定了Port的映射關係，最後取得該Container的Shell。這時環境已經建立起來，我們就可利用PM2把service給run起來：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pm2 start ./bin/www --watch --name "www"</span></code></pre></td></tr></table></div></figure>


<p>然後在Host瀏覽器訪問127.0.0.9453，就可以看到服務啟動了。</p>

<h2>部署在另一台機器上</h2>

<p>把control-center這個Image用<code>save</code>指令匯出成.tar檔</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker save control-center &gt; ./control-center.tar</span></code></pre></td></tr></table></div></figure>


<p>接著在另一台的Dokcer instance上用<code>load</code>指令，指定tar檔路徑匯入成image</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker load &lt; /path/to/control-center.tar</span></code></pre></td></tr></table></div></figure>


<p>再來用<code>docker images</code>來確認是否有成功匯入Image<code>control-center</code>。</p>

<p>之後我們便可以把該Image<code>control-center</code>打包匯出到其他機器，短短的兩行幾秒內就把服務給建立起來，非常輕鬆寫意的部屬方式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -t -i -p 9453:3000 [Image ID] /bin/bash
</span><span class='line'>pm2 start ./bin/www --watch --name "www"</span></code></pre></td></tr></table></div></figure>


<h2>Next</h2>

<p>下次介紹另一個Docker的重要概念：Volume。Container與Image有個很重要原則是裡面不要存Data，也就是不要把MySQL的資料給存在Image裡，所以在資料庫相關的Container裡有關Data的部分會採用另外掛載的方式。</p>

<h3>參考FYI</h3>

<ul>
<li><a href="http://dockone.io/article/783">http://dockone.io/article/783</a></li>
<li><a href="http://dockone.io/article/128">http://dockone.io/article/128</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[期末報告如何才能拿最高分？讓教授幫你做報告]]></title>
    <link href="http://sah.tw/blog/2017/02/01/independent-study-get-good-grades/"/>
    <updated>2017-02-01T00:50:13+08:00</updated>
    <id>http://sah.tw/blog/2017/02/01/independent-study-get-good-grades</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-02-01-independent-study-get-good-grades.jpg" alt="image" /></p>

<p>大家都有這樣的經驗：辛辛苦苦絞盡腦汁，經歷無數夜晚暴肝打word，期末滿懷信心交出報告後，換來的是又一次的失望。</p>

<h2>不斷更新</h2>

<p>如果說一般考試把時間與心力砸下去結果就會好，皇天不負苦心人，那期末報告真的是一件令人頭大的事，時間心力砸下去只怕教授也不領情。那有沒有什麼方法保證最高分？有！很簡單，就是你不能只是把報告做完，你要做到一半就把報告拿給教授看，甚至要拿最高分你有必要寫個一兩頁就傳給教授看。</p>

<p>一開始比如說：「我想要從這家公司他們幾個創辦人的背景開始介紹，你覺得好不好？」，教授可能會說：「我覺得不好，因為xxx是個無趣的人，你不需要介紹他&hellip;.」，這時候你就改麻，然後再問他：「這樣好不好，那你覺得我哪裡可以再加強？」，教授如果說：「那我覺得你可以再focus在這上面&hellip;」，那就再回去加加加，增加篇幅之後再問&hellip;這樣一路反覆執行，到學期末，保證你絕對最高分！但是為什麼呢？</p>

<h2>不是教你諂媚</h2>

<p>注意！答案不是&#8221;最常跟教授接觸&#8221;，那比較像是諂媚，這裡絕對不是教你諂媚。這背後有一個原因為什麼會最高分，因為你這個報告等於是老師幫你做的阿，如果你真的定期跟老師update一些東西，這東西根本就是老師幫你做的阿。那讓老師幫你做這件事情是什麼意思？</p>

<p>剛舉的例子，老師就是那個消費者，你一直去推這個產品、一直去測試消費者，一直修改，直到消費者買單為止麻！你可以一直測試一直測試、一直修改一直修改，不要悶著頭一直寫、不要怕被指出錯誤，這個過程，不管是做報告也好，或是做事情也好，是你最該擁有得一種態度。</p>

<p>不要把所有的事情都堵住到一擲上面，如果你在最後一個禮拜要發表的時候才讓教授知道你的全部想法，看到你的全部東西，你仔細想想，這不是一件在賭樂透的事情嗎？你之前完全都沒有回應耶！也都完全不知道教授對你報告的想法，猜牌算牌都不想做，就在最後一刻突然翻出你的底牌，你根本就是在賭樂透。</p>

<p>跟老師溝通，肯定你的作品，這中間要懂得清楚跟老師表達你做了什麼、清楚理解並記下老師希望你做些什麼、配合老師時間、反覆溝通記錄、鍥而不捨的修改、抓到老師口味、持續的update&hellip;這些都很難耶，這也都是你真正的價值。這些東西比你待在家裡、不用接觸老師、照著自己意思做，那樣最簡單！</p>

<p>不只&#8221;完成報告&#8221;，運用這個來回溝通的方法&#8221;完成老師滿意的報告&#8221;。而出了社會以後，面對上頭交辦下來的事情，別人埋頭苦幹而你會善加利用這點完成事情，成果老闆上司都滿意，你跟別人自然就立分高下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Search應用初探]]></title>
    <link href="http://sah.tw/blog/2017/01/25/search/"/>
    <updated>2017-01-25T18:18:02+08:00</updated>
    <id>http://sah.tw/blog/2017/01/25/search</id>
    <content type="html"><![CDATA[<p>iOS 8之後搭配<code>UISearchController</code>，只要把屬性<code>searchResultsUpdater</code>指定物件在<code>updateSearchResultsForSearchController</code>這個方法中實作filtering and updating就可以了。非常方便。</p>

<h3>Fetch data</h3>

<p>從Server抓取資料，這裡我們用<code>originalDatas</code>這個instace variable存JSON陣列資料。注意Retain Cycle即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Feth data from server and reload.
</span><span class='line'>__weak MemberListTableViewController *weakSelf = self;
</span><span class='line'>[TNUserManager logInAccountInBackgroundWithAccount:@"andy" password:@"12344321" success:^{
</span><span class='line'>    [TNUserManager getContactbookWithSuccess:^(NSDictionary *responseObject) {
</span><span class='line'>        weakSelf.originalDatas = (NSArray*)responseObject;
</span><span class='line'>        [weakSelf.tableView reloadData];
</span><span class='line'>    } failure:^(ResultInfo *resultInfo) {
</span><span class='line'>        NSLog(@"get data fail");
</span><span class='line'>    }];
</span><span class='line'>} failure:^(ResultInfo *resultInfo) {
</span><span class='line'>    NSLog(@"login fail");
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h3>Filtering and Updating</h3>

<p>利用<code>NSPredicate</code>制定陣列搜尋規則，這裡是指定陣列內有包涵<code>searchString</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** Filtering **/
</span><span class='line'>// 搜尋規則
</span><span class='line'>NSPredicate *preicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searchString];
</span><span class='line'>
</span><span class='line'>// 搜尋
</span><span class='line'>NSMutableArray *reslut = [[NSMutableArray alloc]init];
</span><span class='line'>// loop each people
</span><span class='line'>for (NSDictionary *each in self.originalDatas) {
</span><span class='line'>    Boolean isMatch = false;
</span><span class='line'>    
</span><span class='line'>    // list all value of people
</span><span class='line'>    NSMutableArray *values = [NSMutableArray arrayWithArray:[each allValues]];
</span><span class='line'>    
</span><span class='line'>    // 把property的屬性為array的提取出來
</span><span class='line'>    for (id proerty in values) {
</span><span class='line'>        if ([proerty isKindOfClass:[NSArray class]]) {
</span><span class='line'>            if ([proerty filteredArrayUsingPredicate:preicate].count &gt; 0) {
</span><span class='line'>                // show
</span><span class='line'>                isMatch = true;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // 找剩下property的屬性為string的
</span><span class='line'>    if (isMatch == false) {
</span><span class='line'>        if ([values filteredArrayUsingPredicate:preicate].count &gt; 0) {
</span><span class='line'>            // show
</span><span class='line'>            isMatch = true;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    if (isMatch) {
</span><span class='line'>        [reslut addObject:each];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/** Updateing **/
</span><span class='line'>self.showDatas = [reslut mutableCopy];
</span><span class='line'>[self.tableView reloadData];</span></code></pre></td></tr></table></div></figure>


<h3>後續優化idea</h3>

<p>這個APP是做公司內部通訊錄的，而如果陣列裡面包涵員工ID，或到職日期等數字資料，就可以在<code>NSPredicate</code>字串比對完之後，搭配<a href="http://sah.tw/blog/2016/11/09/objc-quick-sort/">Sorting</a>來對數字做排序。</p>

<p>潮一點的搞個數據應用，可以把搜尋歷史用SQLite記錄下來，把<code>搜尋後而且點擊</code>這個元素加入到Sorting的條件中。這樣一來使用者越長搜尋的排序就會越前面囉。</p>

<p>最後也可以做成<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/index.html#//apple_ref/doc/uid/TP40016308">讓iOS系統搜尋Bar也可以找到APP內的資訊</a>，不過這樣就要把通訊錄存在本地端DB，而不能只是In-Memory JSON處理了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[為何愛成吉思汗健身房]]></title>
    <link href="http://sah.tw/blog/2017/01/17/why-love-mma-gym/"/>
    <updated>2017-01-17T23:21:00+08:00</updated>
    <id>http://sah.tw/blog/2017/01/17/why-love-mma-gym</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-01-17-why-love-mma-gym.jpg" alt="image" /></p>

<p>成吉思汗的館長說他開館就是相信台灣應該擁有更好健身房，所以要持續的提供台灣一個高水準的健身聖地，提升台灣人健身運動的專業風氣。討厭看到市場上充斥的都是直銷與只想賺錢的商業健身房與似是而非的健身觀念。</p>

<p>之前去過其他健身房，別的可能就是放很養眼的美女帥男圖，可能也會放勵志標語，比如今天得努力是為了什麼。但我特別喜歡成吉思汗該怎麼做就怎麼做的實幹精神，健身就是會苦，有苦才有收穫。每個人來這裡都是在跟自己比賽，而不是只是來打發時間。我們選擇在此時此刻來到這個健身房，是要互相見證彼此在痛苦中成長，我們能互相體會別人在力竭時努力的叫喊，猙獰的臉龐，而不會阿呦，這是在幹嘛。在這裡大家都在玩真的，真得都在健身，很有熱情想法的在看待這件事！沒有再跟你害羞，沒有再跟你玩半套。在這裡許多地方標語就是no pain no gain。</p>

<p>在這裡密集的上教練課，與教練聊天中知道這裡教練對於定期的考試大家都十分重視，不只是玩玩只求過就好，大家都追求好成績，互相幫忙當捕手教學對方不足之處，這裡教練是真心在追求身體上的進化與突破，跟著這樣的教練才能有學不完的東西，而我相信能夠不斷自我要求的環境這就是好的環境。</p>

<p>成吉思汗直接把台灣制霸印在門口，器材真多超多超齊全，妥善率也都很好，深蹲架排開就是五台，而全年保證不休息，想練隨時都可以來練，就連年過年除夕都不打烊，教練師資真的也專業又敬業。</p>

<h3>為何寫這篇？</h3>

<p>之所以打這一篇是因為跟一位熱愛運動但在考慮上健身房的朋友聊天，偶然聊到為什麼這麼多健身房我選擇了在三重沒有離我家很近的成吉思汗，我突然發現儘管我十分認同喜歡這裡，但我卻完全沒有辦法引起別人的共鳴。後來思考，這應該跟<a href="https://www.youtube.com/watch?v=qp0HIF3SfI4">Simon Sinek那個演講</a>想表達的是一樣。</p>

<p>我都是從WHAT跟HOW來開始跟別人講解，提陳吉思汗優點從有大量專業的器材，很壯的教練，口碑也都不錯的切入，我從WHAT跟HOW切入，結果就是聽的人不能感受成吉思汗特別得地方。我試著從WHY這個角度切入，也希望下次我再推坑其他的人的時候能更引起別人共鳴，推坑成功。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[超級智能時代-人工智慧的不可擋與半世紀影響]]></title>
    <link href="http://sah.tw/blog/2017/01/01/ai/"/>
    <updated>2017-01-01T18:56:12+08:00</updated>
    <id>http://sah.tw/blog/2017/01/01/ai</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-01-02-ai.markdown.JPG" alt="image" /></p>

<p>談一本重要的書，超級智能時代，這本書裡談的議題對每一位讀者都絕對切身相關。人類剛經過一波的資訊革命，最近幾年資訊技術的成熟發展，包含移動網路與終端設備如手機的成熟，帶來資訊大爆炸。資訊大爆炸後有了足夠的數據量，收集起來嘗試找出某些規則，並運用這些規則來使人類生活更方便，也賺取了大把財富。</p>

<p>但從工業時代以來的每一波革命都是先造福一小部分群眾，過了許多年後全人類才能享有革命帶來的好處。這一波大數據與人工智慧的革命帶來的影響與衝擊非常之廣，人工智慧就是想解決以往人類才能解決的問題，會取代許多既有的勞動力，再疊加上一波資訊革命帶來的影響，根據歷史可以想見需要長達半世紀來消化過剩勞動力帶來的負面衝擊。</p>

<h3>從因果法到逆推法</h3>

<p>以往人類學習的方式是習慣先假設某種道理，之後再去累積數據去證明出這種道理;我們習慣先假設因，才去驗證結果。上幾個世紀人類都習慣這套思考模式，稱之為工業時代思考模式。而當時間來到現在，容易尋找的真理幾乎都被發現完了，我們要面對的是不確定性越來越高的問題，往往我們連問題該怎麼定義都沒有頭緒，所以藉由累積數據來說故事，從資料裡發現道理，便是為了回答現代越發複雜，且不確定性極高的智慧型問題的新思考模式。</p>

<h3>現代人工智慧</h3>

<p>其實大數據不是用來解決人工智慧的唯一方法。最早其實科學家是想模仿人類思考模式來製造人工智慧，但發現難以解決不確性高的問題。而隨著硬體如儲存技術得成熟，連結技術如移動網路的成熟，處理能力如資料中心的成熟，這三者技術同時準備好了，使得人類發現與其讓機器造著人類的想法走，不如餵給機器一堆資料，讓它從中自己試著回答問題，結果比之前的方法就結果來說都更好。</p>

<p>逆推方方法論變成資訊時代的方法論。</p>

<p>順著這個思考模式可以發現。掌握數據，更嚴格來講是大數據的人在未來才有可能回答現代社會中越發複雜的問題。大數據顧命思議就是大量的資料，而大量的數據加上多維度，便能從中去試著找出規律，總結成智慧。</p>

<p>所以從人工智慧方向往大數據的逆推方法論走後，『人類在人工智慧領域的成就，其實就是把各種智慧問題轉化為消除不確定性的問題，然後再找到能消除相應不確定性的資訊』。</p>

<p>下圍棋人類依靠經驗與眾多棋譜來學習如何取勝，而只要能把棋譜轉換成電腦可懂的規則，電腦就可以大量的去讀取歷史棋譜，能比任何人類一輩子讀的都還要多，最後轉換成數學模式，採用依照大量數據訓練加上統計知識所做出來的模型來回答問題。雖然棋的變化是無窮的，但機器總能找出勝率較高的步法。</p>

<p>AlphaGo在比賽中走出許多令人類專家跌破眼鏡的走法，但最後又能贏。這裡重點在於機器不必像人一樣思考，只要能夠解決人的問題就好了。在大數據中得出的智慧是數據加上統計的及果，是有可能出乎人意料外的，而且能做的更好。能不照常規行事其實就是超級智慧的表現。</p>

<p>而AlphaGo知道自己在下棋嗎？當然不知道。只不過把智慧問題轉換成數據問題。用統計方法搭配大數據解決智慧問題後機器從此無敵。</p>

<p>所以對於行事有特定SOP的技能，也就是非創造性工作的從業人員，大數據加上人工智慧是大有取代的勢頭。比如基金操盤手、醫師、會計師、司機、護士、農夫等。</p>

<h3>智能革命的影響</h3>

<p>在未來掌握大數據與運算能力的少數巨頭，目前來看如Google, FB, Apple, Amazon, Netflex和大陸的bat，這些公司如果和公權力結合，那就是全面監控了。CIA要來台灣抓人其實不用跟台灣警察打交道，透過你使用的手機說不定還比台灣警察更知道你的所在地。免費的服務往往是用自由換來的。你提供時間與數據，巨頭提供免費服務。在未來隱私的保護是重要議題。</p>

<p>技術帶來的各命常常是憂喜參半，喜的是改善人類生活，讓一些處在浪尖的人發揮更大的作用。但因為技術進步而被取代的人力，往往沒有辦法在學習新技術，所以只好『養著』，耗上兩代就解決問題了。</p>

<p>這次的超級智能最重要的影響是人類會發現自己能做得比機器好的事情不多了，很多人會在技術進步的途中發現自己被拋下了，新技術的發展不是每個人的機會都會變多，許多人反而是機會變少，如全自動化工廠之於生產線工人，計程車司機之於自動駕駛技術。這些大量勞動力該如何解決？書中其實沒有提出解決辦法，只能接受接在未來的幾10年會有越來越多事人類贏不了機器人。而之後所做的決定也都要依照這個大前提去行動。</p>

<h3>對於我個人</h3>

<p>看完這本書心中是興奮與恐懼，興奮的是對未來人類生活充滿正面積極的想像，恐懼的是害怕自己是對這未來至少50年影響人類最深遠的領域一無所知，最終被拋下，在自己的工作生涯毫不自豪。幸好我是相關科系相關產業，也還年輕肯學有興趣，往後推10年的努力都要與人工智能領域有關，投入在相關領域是我對自己未來的規劃。</p>

<p>以下是Youtube連結，台大教授林軒田老師的<a href="https://www.youtube.com/playlist?list=PLXVfgk9fNX2I7tB6oIINGBmW50rrmFTqf">機器學習基石</a> FYI。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AirPods個人使用評測：『能夠預知下一步的真智慧型耳機』]]></title>
    <link href="http://sah.tw/blog/2016/12/27/airpods/"/>
    <updated>2016-12-27T17:19:23+08:00</updated>
    <id>http://sah.tw/blog/2016/12/27/airpods</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2016-12-27-airpods.jpg" alt="image" /></p>

<p>說到無線藍芽耳機我也是重度愛好者，早在前年就花了5位數大洋買了Sony的藍芽耳罩耳機<code>MDR-1RBTMK2</code>，那時候最麻煩的地方在於配對的不穩定和麻煩，都要先按鈕換醒耳機等待手機配對，有時找不到還要自己去連線。還有麥克風根本是雞肋，完全不能拿來講電話收音非常差，一有電話打來常常是手忙腳亂拔耳機選擇本機的Mic等等&hellip;好在上述的問題在AirPods都被完美的解決了。</p>

<h3>方便到一切成自然的拔掉單邊耳機</h3>

<p>常常戴耳機遇到一個情況是別人突然來找你講話，這時候拿掉一邊耳機另一邊都還播著歌，有時還是要手動把音樂關掉，而AirPods你只要拿掉其中一邊耳機，手機立即就會停止播放歌曲，真的是很實用的功能。</p>

<p>再來重點當你講完話，把耳機再放回耳朵時，音樂又會聰明的自動開始播放了！一切真的就是方便到成自然。想像你帶著耳機在電影，突然有人打擾！你帥氣的拿下單邊耳機電影立刻自動暫停，講完之後再戴回去電影立刻繼續播放！Magic~</p>

<p>你的下一個動作都預先被做好了，對我來說這就是智慧型產品，就叫方便！</p>

<h3>兩邊耳機都拿掉</h3>

<p>以前我用過的藍牙耳機當你兩邊都拿掉之後，你可能就是回到家不需要他們了，這時還要去手機裡面把輸出模式切換為原本的喇叭，多此一舉。而AirPods會自動偵測到你把兩邊耳機都拿掉了，iOS Device會自動把輸出切換回本機的模式。日常使用起來也是非常方便。</p>

<h3>麥克風</h3>

<p>真的很神奇，明明麥克風不在你嘴邊是在耳朵旁，可是你講出來的話還是很清楚的被收音了。使用AirPods後講了很多電話沒有人跟我反應不清楚。最後如果特別有問都會說我這邊收音很清楚很清晰。不管在捷運上或大馬路或安靜辦公室裡都OK的。</p>

<h3>連線穩定度</h3>

<p>搭配iOS Device很穩，就是穩。我想這是基本的啦。</p>

<h3>音質</h3>

<p>高音感受與有線一樣，低音感受比有線好蠻多的，至少我有感啦。音質很主觀，很在意的還是親耳聽聽吧。如果可以接受原廠有線的，那AirPods這個應該沒問題。</p>

<h3>電力與充電</h3>

<p>AirPods本身支援快充，你聽到剩4%快沒電了，放回AirPods case（就上面那個方形小盒子），約不到15分鐘就充超過一半了。充滿一次可以聽大概5個小時。實際使用上跟官方給的數據都很相近。自己用起來完全不擔心缺電。</p>

<h3>外觀</h3>

<p>這個就不用太在意吧，音樂是自己在聽的，而且也不是什麼新設計，就是之前有線的長相呀，只是沒有線。真的很在意的就等多一點人戴再買吧，哈哈。按照官網購買要排到6個禮拜後的情況，我想以後路上會很常看到的。</p>

<h3>會不會掉？醒著的時候都不會掉</h3>

<p>什麼意思勒？我帶著AirPods慢步，重訓（有時需要躺著），出門坐捷運加上走一大段路，尖峰時刻搭捷運有時難免跟路人碰撞，以上情況都沒有掉過！有線的反而常常搭捷運太擠線勾到還會被扯掉。</p>

<p>唯獨有一次搭客運睡著頭往一邊肩膀倒，然後客運晃阿晃抖阿抖的，那邊的AirPods就掉了&hellip;嚇出一身冷汗，還好那天穿帽T醒來之後AirPods還在我肩膀上。所以，如果你快睡著又剛好身體會晃來晃去就要注意一點了。</p>

<h3>快速跨多裝置使用超方便</h3>

<p>如果你同時有Macbook, iPhone, iPad，而且都使用同一個有線耳機，常常插拔真的頗麻煩。AidPods只要Device都使用同一個Apple ID，每個裝置都不用再額外配對就可以很快速的連接上你的AirPods。</p>

<p>我常常很賭爛Macbook上的耳機孔，真的很難拔，常常只是要上個廁所我就要拔下來再插上手機，回到座位上又要Repeat這個動作。有了AirPods之後就超方便的，只要手機帶著就自動會有AirPods選項讓你選，點一下就切換到手機上了。</p>

<h3>缺點</h3>

<p>使用下來真的沒有感受到什麼缺點，對比有線耳機只有更方便更智慧的感受。真要說的話就是AirPods上面沒有按鈕可以按，也就是說沒有傳統有線上的上下首與大小聲按鈕。AirPods現在只能感應點兩下這個動作，點兩下來叫出Siri或是點兩下暫停/播放。</p>

<p>雖然說是缺點但我的習慣是出門手上都會拿著耳機，基本上手機不離身，所以要上下一首或調音量，把畫面喚醒就可以直接操作了，實際使用上其實也沒有感覺到不便。</p>

<h3>總結</h3>

<p>毆對了！還有價錢。5000多大洋就是考驗每個人用錢價值觀的時刻了。上面舉了那些優點還有缺點，我只能說差不多的錢就功能上還有方便性智慧性等，目前市面上我認為還沒有競爭對手。</p>

<p>對我來說，耳機是我每天必用到的東西，如果每天都能少那麼一點煩惱，比如花時間解開那一坨線, 插拔的動作, 有時會扯到, 原廠有線用久其實真的很容易接觸不良還是要買新的等等，加上上面提的優點，OK 我買單。</p>

<p>我不算盲目的果粉，近期Apple的產品包含iPhone 7跟新Macbook如果有人詢問我意見我都會叫他們再等等，但這個AirPods真的很推，Apple近期難得好作品，預算夠我都會推薦買Der~。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[從Youtube使用Tabbar討論逐漸被棄用的側邊欄]]></title>
    <link href="http://sah.tw/blog/2016/11/20/youtubeshi-yong-tabbar/"/>
    <updated>2016-11-20T11:56:52+08:00</updated>
    <id>http://sah.tw/blog/2016/11/20/youtubeshi-yong-tabbar</id>
    <content type="html"><![CDATA[<h2>側邊欄逐漸被棄用的原因</h2>

<p>iOS版YouTube把Tabbar加上去了。前陣子流行的各種想取代Tabbar導航方式的方案又改回來了。</p>

<p><img src="http://mrshih.github.io/images/2016-11-20-youtubeshi-yong-tabbar.jpeg" alt="image" /></p>

<p>Tabbar是固定出現在下面的（除了播放影片時）。而看了些文章，最主要還是用戶真的太太太太懶，多一丁點步驟都懶得按，所以就乾脆固定在那裡。這樣努力做的各種功能的使用率比較高！</p>

<p>不過Uber是個有趣的例子！Uber用漢堡是因為其他功能的點擊率高不是goal，所以可以用Hamburger menu。</p>

<h2>如何決定要用哪種設計？A/B Testing</h2>

<p>Youtube跟Spotify決定從原本側邊欄轉移到Tabbar都是因為測過A/B Testing，用結果數字來說話。</p>

<p>這其實也牽扯到如何設計A/B Testing？一個APP最關鍵的不是他介面看起來炫不炫，而是最終用戶能不能持續地用你想讓他用的功能。記住If<strong><strong> ,Then</strong></strong> ,Because___.</p>

<p>如果你的變因錯誤的把畫面好看當成目標，那你甚至會覺得隨著畫面滾動把Tabbar隱藏起來是好的。那這樣一來或許畫面變好看，可是面積變多，但你APP整體功能使用率是下降的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary search與Obj-C]]></title>
    <link href="http://sah.tw/blog/2016/11/18/binary-searchyu-obj-c/"/>
    <updated>2016-11-18T16:41:19+08:00</updated>
    <id>http://sah.tw/blog/2016/11/18/binary-searchyu-obj-c</id>
    <content type="html"><![CDATA[<h2>Binary search概念</h2>

<p>Binary search概念其實很簡單，recursive版本實際寫起來很像<a href="http://sah.tw/blog/2016/11/09/objc-quick-sort/">Quick sort in-place</a>版本前面divide的味道。每次的遞迴都把排序後的數列對切一半然後去其中一半來繼續處理，詳細可以看<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">Wiki</a>的介紹。</p>

<h2>Binary search概念轉換成Code</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * @return Retrun index of number in array.
</span><span class='line'> * If number not found in array return false.
</span><span class='line'> */
</span><span class='line'>- (NSNumber *)binarySearchIndexInArray:(NSArray &lt;NSNumber *&gt;*)array forNumber:(NSNumber *)number leftRange:(NSInteger)left rightRange:(NSInteger)right {
</span><span class='line'>    
</span><span class='line'>    if (left &gt; right) {
</span><span class='line'>        return [NSNumber numberWithBool:false];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSInteger midIndex = (left+right)/2;
</span><span class='line'>    NSNumber* mid = array[midIndex];
</span><span class='line'>    
</span><span class='line'>    if (number.floatValue &gt; mid.floatValue) { // 對切的右邊
</span><span class='line'>        return [self binarySearchIndexInArray:array forNumber:number leftRange:midIndex+1 rightRange:right];
</span><span class='line'>    }else if (number.floatValue &lt; mid.floatValue){ // 對切的左邊
</span><span class='line'>        return [self binarySearchIndexInArray:array forNumber:number leftRange:left rightRange:midIndex-1];
</span><span class='line'>    }else{ // equal，找到了
</span><span class='line'>        return  [NSNumber numberWithInteger:midIndex];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>關於搜尋</h2>

<p>這個搜尋法的前提是你的數列要幾經排序好了。這個前置條件才讓我發現我之前一直以為搜尋是有什麼神奇的方法，能夠在一個大數列裡面找到target的位置，現在接觸演算法就理解現實運作方法是先排序之後再用方法搜尋的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickSort與Obj-C]]></title>
    <link href="http://sah.tw/blog/2016/11/09/objc-quick-sort/"/>
    <updated>2016-11-09T10:24:20+08:00</updated>
    <id>http://sah.tw/blog/2016/11/09/objc-quick-sort</id>
    <content type="html"><![CDATA[<h2>Qucik Sort概念</h2>

<p>第一次看到快速排序的許多介紹，可能第一時間腦袋轉不太過來，因為網路介紹常常把虛擬碼翻成步驟，直接敘述，所以腦袋普通像我就會沒辦法意會為什麼要做這個動作。比如後面會提到的In-Place版本交換這個動作就常常不知為何而做。這裡有個<a href="https://www.youtube.com/watch?v=aQiWF4E8flQ">影片</a>是從很高層次想法上去解釋Quick Sort，個人看了之後再想想虛擬碼，也就豁然開朗了。</p>

<h2>Qucik Sort概念轉換成Code</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)quickSortUseExtraMemoryWithData:(NSArray *)data {
</span><span class='line'>
</span><span class='line'>    if (data.count &lt;= 1) { // 到底部了, 不需要排序, 直接回傳
</span><span class='line'>        return data;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    int random = arc4random() % data.count;  // 隨機取用某index當pivot，避免比如排序已經排好的陣列，每次都取index0，會造成時間複雜度O(N^2)，worst case
</span><span class='line'>    NSNumber *pivot = data[random];
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *less = [[NSMutableArray alloc]init];
</span><span class='line'>    NSMutableArray *greater = [[NSMutableArray alloc]init];
</span><span class='line'>    
</span><span class='line'>    for (int i=1; i&lt;=data.count-1; i++ ) {
</span><span class='line'>        if ([(NSNumber *)data[i]floatValue] &gt;= [pivot floatValue]) {
</span><span class='line'>            [greater addObject:data[i]];
</span><span class='line'>        }else {
</span><span class='line'>            [less addObject:data[i]];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *result = [[NSMutableArray alloc]init];
</span><span class='line'>    [result addObjectsFromArray:[self quickSortUseExtraMemoryWithData:less]];
</span><span class='line'>    [result addObject:pivot];
</span><span class='line'>    [result addObjectsFromArray:[self quickSortUseExtraMemoryWithData:greater]];
</span><span class='line'>    
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果常寫有支援記憶體管理語言比如Java或ARC版Obj-C的人可能會直覺寫出這個版本，因為在這幾個語言裡其實常常不用太管記憶體使用量太多這個問題，除非是<code>UIImage</code>等大型物件沒有釋放，不然常常遇到比如<code>NSArray</code>分割其實也就是再開兩個NSArray去存就好了。</p>

<p>上面這個實作方法每次都新開<code>NSArray</code>去存放分割後的子Array，而Quick Sort比Merge Sort好的地方在於它可以改用稱作In-Place的方法，只在同一個陣列做交換，可以避免運用消耗多餘的記憶體空間，參考文獻也寫說實務上也可以增加演算法的效率。</p>

<h2>Qucik Sort In-Place 版本</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSMutableArray *)quickSortInPlaceWithData:(NSMutableArray &lt;NSNumber *&gt;*)data leftIndex:(NSInteger)left rightIndex:(NSInteger)right{
</span><span class='line'>    // 使用in-place法，操作同一個陣列，避免額外消耗多餘記憶體，硬體限制嚴格的環境下使用
</span><span class='line'>    
</span><span class='line'>    if (left &gt; right) { // 底部。代表上一層遞迴切出來，這個sub-array已經只有一個元素，就不用排列了，'這個元素也會是已經就定位的'。
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSNumber *pivot = data[right];
</span><span class='line'>    
</span><span class='line'>    NSInteger processIndexAKAWall = left;
</span><span class='line'>    [data exchangeObjectAtIndex:right withObjectAtIndex:right];// 把pivot移到最後面
</span><span class='line'>    for (int i=(int)left; i&lt;right; i++ ) { // left ... right-1
</span><span class='line'>        if ([data[i]floatValue] &lt; [pivot floatValue]) {
</span><span class='line'>            [data exchangeObjectAtIndex:processIndexAKAWall withObjectAtIndex:i];// 擺到牆的右邊
</span><span class='line'>            processIndexAKAWall = processIndexAKAWall + 1;// 牆往前
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    [data exchangeObjectAtIndex:processIndexAKAWall withObjectAtIndex:right];// 把pivot移到牆的右邊。這個pivot目前已經在正確的index上了。
</span><span class='line'>    
</span><span class='line'>    // 切兩段
</span><span class='line'>    // start by left, end by processIndexAKAWall - 1
</span><span class='line'>    // start by processIndexAKAWall + 1, end by right
</span><span class='line'>    [self quickSortInPlaceWithData:data leftIndex:left rightIndex:processIndexAKAWall - 1];
</span><span class='line'>    [self quickSortInPlaceWithData:data leftIndex:processIndexAKAWall + 1 rightIndex:right];
</span><span class='line'>    
</span><span class='line'>    return data;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>更好用的呼叫方式</h2>

<p>平均空間複雜度更好的In-Place版本，因為只有<code>NSMutableArray</code>可以交換item，所以如果傳入值是是<code>NSArray</code>則呼叫的時候要寫成以下方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray *result = [self quickSortInPlaceWithData:[data mutableCopy] leftIndex:0 rightIndex:data.count-1];</span></code></pre></td></tr></table></div></figure>


<p>而為了可以讓<code>NSArray</code>可以使用，也方便之後做成<code>NSArray</code>的<code>Category</code>，就可以改寫成以下這種較為方便別人使用的方式，因為別人不一定知道Left與Right，也不需要懂實作細節情況下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)quickSort:(NSArray *)data {
</span><span class='line'>    return [self quickSortInPlaceWithData:[data mutableCopy]  leftIndex:0 rightIndex:data.count-1];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MergeSort與Obj-C外加Category與OOP]]></title>
    <link href="http://sah.tw/blog/2016/11/07/objc-merge-sort-category-oop/"/>
    <updated>2016-11-07T00:18:53+08:00</updated>
    <id>http://sah.tw/blog/2016/11/07/objc-merge-sort-category-oop</id>
    <content type="html"><![CDATA[<h2>Merge Sort概念</h2>

<p>跟我一樣原本不知道Merge Sort是什麼碗糕的可以去這個<a href="https://www.youtube.com/watch?v=mzjjRPdH9Jw">影片</a>，這裡有可愛北一女的實際示範，中文的呦。如果英文好那我也是更推薦去看英文的，那資源又更多了。</p>

<h2>Merge Sort概念轉換成Code</h2>

<p>在懂了Merge Sort概念之後，如果對於如何把想法轉換成程式碼沒什麼感覺，可以看一段<a href="https://www.youtube.com/watch?v=es2T6KY45cA&amp;index=3&amp;list=PL2aHrV9pFqNRS2b2XX2BvgQIPKh72xREP">影片</a>，這段影片大概就是程式碼影片化後實際運作的樣子。</p>

<p>Merge Sort有分Recursive跟For loop兩種，但看完影片直覺就是用Recursive比較好做。這是因為你看Merge Sort其實是把一個大問題分成小問題，小問題再分成更小的問題，直到把問題切割成最小單元，再返回來把前一次的結果餵給上一層，之後一層一層的解回去。這是很典型的遞迴場景。
NSMutableArray
上面的問題解決思路在演算法裡面叫做Divide and Conquer，蠻傳神的解釋，把問題分解後在各個擊破。</p>

<h2>Objective-c Implement</h2>

<ul>
<li>Input為一個NSArray，裡面包含N個NSNumber，NSNumber可以為Int或Flot。</li>
<li>Output為一個把Input Array裡面的N個NSNumber由小排序到大的NSArray。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)mergeSortWithData:(NSArray *)data {
</span><span class='line'>    
</span><span class='line'>    if (data.count == 1) {
</span><span class='line'>        // div done here
</span><span class='line'>        // 這裡已經把問題分解成最小單位了，所以就告一段落
</span><span class='line'>        return data;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSInteger divLength = data.count/2;
</span><span class='line'>    NSArray *left = [data subarrayWithRange:NSMakeRange(0, divLength)];
</span><span class='line'>    NSArray *rigth = [data subarrayWithRange:NSMakeRange(divLength, data.count-divLength)];
</span><span class='line'>    
</span><span class='line'>    NSArray&lt;NSNumber*&gt; *mergeArrayA = [self mergeSortWithData:left];
</span><span class='line'>    NSArray&lt;NSNumber*&gt; *mergeArrayB = [self mergeSortWithData:rigth];
</span><span class='line'>    
</span><span class='line'>    NSInteger headOfMergeArrayA = 0;
</span><span class='line'>    NSInteger headOfMergeArrayB = 0;
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *resultArray = [[NSMutableArray alloc]initWithCapacity:mergeArrayA.count+mergeArrayB.count];
</span><span class='line'>    
</span><span class='line'>    Boolean control = true;
</span><span class='line'>    while (control) {
</span><span class='line'>        
</span><span class='line'>        if (headOfMergeArrayA == mergeArrayA.count) {
</span><span class='line'>            //MergeArrayA沒東西了
</span><span class='line'>            //把剩餘的MergeArrayB直接append到resultArray後面
</span><span class='line'>            [resultArray addObjectsFromArray:[mergeArrayB subarrayWithRange:NSMakeRange(headOfMergeArrayB, mergeArrayB.count-headOfMergeArrayB)]];
</span><span class='line'>            control = false;
</span><span class='line'>            break;
</span><span class='line'>        }else if(headOfMergeArrayB == mergeArrayB.count){
</span><span class='line'>            [resultArray addObjectsFromArray:[mergeArrayA subarrayWithRange:NSMakeRange(headOfMergeArrayA, mergeArrayA.count-headOfMergeArrayA)]];
</span><span class='line'>            control = false;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        if ([mergeArrayA[headOfMergeArrayA]floatValue] &gt; [mergeArrayB[headOfMergeArrayB]floatValue]) {
</span><span class='line'>            [resultArray addObject:mergeArrayB[headOfMergeArrayB]];
</span><span class='line'>            headOfMergeArrayB = headOfMergeArrayB + 1;
</span><span class='line'>        }else{
</span><span class='line'>            [resultArray addObject:mergeArrayA[headOfMergeArrayA]];
</span><span class='line'>            headOfMergeArrayA = headOfMergeArrayA + 1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return resultArray;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Do more &ndash; Free Function與Method</h2>

<p>可以看到<code>mergeSortWithData</code>是一個Function，但我自己Obj-C軟體實作的Coding style上如果一個Function的Input有指定要是某個Class，比如這裡就是指定<code>NSArray</code>，那這時候採用Method較好。</p>

<p>但通常很少情況會不指定Input的Clsas，所以實務上會盡量少用Free Function，附帶的好處是可以減少一堆Function散落在專案裡面，也可以盡量DRY（Don&rsquo;t repeat yourself）。</p>

<p>當然，不要過度強調DRY，因為這關係到切架構與抽象化整體的規劃能力，抽象的不好那是會用弄越糟的，但至少在這個簡單的Case裡Merge Sort做成Method絕對是make sense的。</p>

<p>這裡可以練習把Merge Sort用<code>Category</code>的方式做成<code>NSArray</code>的Method。基礎OOP，把一些地方改成<code>Self</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[In-App-Purchase交易模組設計]]></title>
    <link href="http://sah.tw/blog/2016/08/24/iap-payment-model-design/"/>
    <updated>2016-08-24T23:30:18+08:00</updated>
    <id>http://sah.tw/blog/2016/08/24/iap-payment-model-design</id>
    <content type="html"><![CDATA[<p>網路上很多介紹如何運用<code>StoreKit</code>裡面的API在iOS上付款的文章，但實務上因為<code>In-App-Purchase</code>是程式裡面需要密集配合業務需求的部分，如果沒有一個良好抽象化的設計，在高可維護性與彈性，可擴展能力下功夫，一旦業務需求一複雜或反覆迭代更改，就會讓IAP相關的邏輯變得難以修改與維護。</p>

<p>以上原因，所以如何在APP中設計一套可維護可擴展易整合的IAP架構，是開發大型APP與進階開發者應該關心的議題。接下來的文章把IAP付款架構有關執行交易與交易結果處理的這部分，抽象成TNStoreObserver類別。</p>

<h2>StoreObserver</h2>

<p>付款流程是APP根據一組定義在iTunesConnect的商品ID，向Apple Server請求對應的<code>SKPayment</code>物件，裡面包含了Localization的商品名稱與價錢，把這個想成一個商品。而一旦把這個<code>SKPayment</code>物件放到由系統維護的<code>SKPaymentQueue</code>時，這時候就開始進入按指紋，輸入iTunes Store帳密的程序。</p>

<p>而<code>StoreKit</code>說明，當<code>SKPayment</code>加入到<code>SKPaymentQueue</code>後，開發者需要實作一個adopt<code>SKPaymentTransactionObserver</code>protocol的物件，並加入到<code>SKPaymentQueue</code>裡。之後這個Observer就是負責處理各種交易結果。比如成功時就要開啟對應的功能等。</p>

<p>所以這個Class就取名叫StoreObserver，職責是實作<code>SKPaymentTransactionObserver</code>protocol，處理交易完成的後續行為。並負責與<code>SKPaymentQueue</code>互動，比如購買，取回過去的購買紀錄。最後可方便的在任何地方發動購買，然後在需要的地方容易接收到結果。</p>

<p>基於以上需求，開去構思這個模組。</p>

<p>先處理交易的部分，這就是單純與StoreKit串接。以下兩個Public方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 購買SKProduct
</span><span class='line'>// Create and add a payment request to the payment queue
</span><span class='line'>-(void)buy:(SKProduct *)product
</span><span class='line'>{
</span><span class='line'>    SKMutablePayment *payment = [SKMutablePayment paymentWithProduct:product];
</span><span class='line'>  [[SKPaymentQueue defaultQueue] addPayment:payment];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 取回過去完成交易的非消耗品購買與自動續訂紀錄
</span><span class='line'>-(void)restore
</span><span class='line'>{
</span><span class='line'>    [[SKPaymentQueue defaultQueue] restoreCompletedTransactions];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>實作上會把這個<code>StoreObserver</code>做成<code>Singleton</code>，因為APP裡面可能會有許多頁面允許付款，只要<code>[[StoreObserver sharedInstance] buy:product];</code>就可以購買商品。然後因應上面的<code>restore</code>方法，這裡需要一個<code>NSArray</code>來裝取回的商品們，命名為<code>productsRestored</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (StoreObserver *)sharedInstance
</span><span class='line'>{
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    static StoreObserver * storeObserverSharedInstance;
</span><span class='line'>    
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        storeObserverSharedInstance = [[StoreObserver alloc] init];
</span><span class='line'>    });
</span><span class='line'>    return storeObserverSharedInstance;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>- (instancetype)init
</span><span class='line'>{
</span><span class='line'>  self = [super init];
</span><span class='line'>  if (self != nil)
</span><span class='line'>    {
</span><span class='line'>        _productsRestored = [[NSMutableArray alloc] initWithCapacity:0];
</span><span class='line'>    }
</span><span class='line'>  return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>這邊重要的來了，如果程式的某個地方呼叫了<code>StoreObserver</code>的<code>buy</code>發法，之後<code>StoreObserver</code>收到交易完成的資訊，而APP裡面可能會有很多地方因為這個交易而產生UI上的變化，比如買了一部影片，影片要開始播放，影片櫃需要新增新影片，會員的購買紀律需要增加一筆。該怎麼通知那麼多地方？這裡用了<code>NSNotificationCenter</code>。</p>

<p>為什麼呢？因為在上述一對多的狀況下，<code>StoreObserver</code>會被設計成它不關心那些畫面或地方需要這些訊息。但它會把資料準備好，接著廣播。</p>

<p>當通知的人不關心他會通知到誰，但可能需要被通知的人很多時，<code>NSNotificationCenter</code>機制就派上用場了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString * const TNIAPPurchaseNotification = @"TNIAPPurchaseNotification";</span></code></pre></td></tr></table></div></figure>


<p>再來是讓接收廣播的地方容易做處理。在這個Class裡面我們設置三個Property，<code>status</code>，<code>message</code>和<code>purchasedID</code>。當這個Class實作<code>SKPaymentTransactionObserver</code>時，根據收到的資訊做整理，讓接收的人可以很方便利用交易結果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_ENUM(NSInteger, TNIAPPurchaseNotificationStatus)
</span><span class='line'>{
</span><span class='line'>    TNIAPPurchaseFailed, // Indicate that the purchase was unsuccessful
</span><span class='line'>    TNIAPPurchaseSucceeded, // Indicate that the purchase was successful
</span><span class='line'>    TNIAPRestoredFailed, // Indicate that restore products was unsuccessful
</span><span class='line'>    TNIAPRestoredSucceeded // Indicate that restore products was successful
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>@property (nonatomic) TNIAPPurchaseNotificationStatus status;
</span><span class='line'>@property (nonatomic, copy) NSString *purchasedID;
</span><span class='line'>@property (nonatomic, copy) NSString *message;</span></code></pre></td></tr></table></div></figure>


<p>比如當我們實作的<code>SKPaymentTransactionObserver</code>方法被<code>SKPaymentQueue</code>呼叫時，整理一下再POST Notification出去</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Called when an error occur while restoring purchases. Notify the user about the error.
</span><span class='line'>- (void)paymentQueue:(SKPaymentQueue *)queue restoreCompletedTransactionsFailedWithError:(NSError *)error
</span><span class='line'>{
</span><span class='line'>    if (error.code != SKErrorPaymentCancelled)
</span><span class='line'>    {
</span><span class='line'>        self.status = IAPRestoredFailed;
</span><span class='line'>        self.message = error.localizedDescription;
</span><span class='line'>        [[NSNotificationCenter defaultCenter] postNotificationName:TNIAPPurchaseNotification object:self];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>實際運作</h2>

<p>這邊我們不考慮要怎麼取得到SKPayment物件，因為這部分邏輯不在<code>StoreObserver</code>負責範圍內。</p>

<h3>在任何地方容易的發動購買</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SKProduct *product = (SKProduct *)productRequestResponse[indexPath.row];
</span><span class='line'>        // Attempt to purchase the tapped product
</span><span class='line'>        [[TNStoreObserver sharedInstance] buy:product];</span></code></pre></td></tr></table></div></figure>


<h3>在需要的地方容易收到並做處理</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[NSNotificationCenter defaultCenter] addObserver:self
</span><span class='line'>                                             selector:@selector(handlePurchasesNotification:)
</span><span class='line'>                                                 name:TNIAPPurchaseNotification
</span><span class='line'>                                               object:[StoreObserver sharedInstance]];
</span><span class='line'>
</span><span class='line'>// Update the UI according to the purchase request notification result
</span><span class='line'>-(void)handlePurchasesNotification:(NSNotification *)notification
</span><span class='line'>{
</span><span class='line'>    StoreObserver *purchasesNotification = (StoreObserver *)notification.object;
</span><span class='line'>    
</span><span class='line'>    IAPPurchaseNotificationStatus status = (IAPPurchaseNotificationStatus)purchasesNotification.status;
</span><span class='line'>    NSString *message = purchasesNotification.message;
</span><span class='line'>    NSString *purchasedID = purchasesNotification.purchasedID;
</span><span class='line'>   
</span><span class='line'>
</span><span class='line'>  switch (status)
</span><span class='line'>    {
</span><span class='line'>        case IAPPurchaseFailed:
</span><span class='line'>            //購買失敗...
</span><span class='line'>          break;
</span><span class='line'>            
</span><span class='line'>        case IAPDownloadSucceeded:
</span><span class='line'>        {
</span><span class='line'>            //購買成功...
</span><span class='line'>        }
</span><span class='line'>          break;
</span><span class='line'>        
</span><span class='line'>        case IAPRestoredSucceeded:
</span><span class='line'>        {
</span><span class='line'>            //回復成功...
</span><span class='line'>        }
</span><span class='line'>            break;
</span><span class='line'>            
</span><span class='line'>        case IAPRestoredFailed:
</span><span class='line'>            //回復失敗...
</span><span class='line'>            break;
</span><span class='line'>  } 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[從零到穩固的基礎 - 談iOS刻畫UI]]></title>
    <link href="http://sah.tw/blog/2016/08/11/ios-view-advanced/"/>
    <updated>2016-08-11T22:02:46+08:00</updated>
    <id>http://sah.tw/blog/2016/08/11/ios-view-advanced</id>
    <content type="html"><![CDATA[<p>MVVM是iOS開發近來熱門的開發架構，最近工作上不停用到這個架構去建立各種頁面，對於如何從零開始架構出一個方便開發與維護的MVVM架構有些實作上總結出的Tips或稱為想法在，這裡記錄下來與回顧。</p>

<p>系列第一篇會先從MVVM裡面的View開始講，通常這也是我開發的第一也是很重要的步驟，這裡一開始沒規劃好浪費的時間絕對是最多的，因為方向就錯了麻。</p>

<h2>看UI圖然後先想想</h2>

<p>第一步當然就是看著UI出好的圖，然後想想這個畫面上會用的什麼<code>UIKit</code>的控件。大部分不外乎是<code>TableView</code>, <code>CollectionView</code>, <code>PageView</code>，互相搭配即可組出框架。某些例外比如登入登出註冊頁面則通常就會一張空白<code>View</code>自己拉畫面，不太用到上面提到的控件。</p>

<p>真的有問題比如需要重新打造一個控件，或不好實作，卡到時間等，都在這裡即時反應給UI是最好的。不會先做下去遇到問題卡住再來溝通，這樣事倍功半真的也很浪費時間。</p>

<h2>先大致上命名好</h2>

<p>曾經有看過程式設計裡面在資深開發人員裡排名第一的難題是命名。這是因為如果一開始沒有想好階層式的命名方式，等到架構一大你就會開始需要在腦袋裡面Dump一堆記憶體來存這些Name的意義，久了也一定會忘記。</p>

<p>比如常見的新聞頁面</p>

<p><img src="http://sah.tw/images/2016-08-11-ios-view-advanced.png" alt="YahooNews" /></p>

<p>這個頁面大致需要下面幾個控件:</p>

<ol>
<li>主要<code>ViewController</code></li>
<li>一個<code>CollectionView</code>來當Indicator，顯示有那些類別</li>
<li>一個<code>PageController</code>來橫向翻頁在不同類別的新聞頁面</li>
<li>多個<code>TableView</code>拿來顯示新聞</li>
</ol>


<p>那在命名上就要先大致想好：</p>

<ol>
<li><code>SHReaderViewController</code></li>
<li><code>SHReaderCategoryIndicatorViewController</code> &ndash; <code>SHReaderCategoryIndicatorCell</code></li>
<li><code>SHReaderPageViewController</code></li>
<li><code>SHReaderNewsViewController</code> &ndash; <code>SHReaderNewsCell</code></li>
</ol>


<p>只要名字的Prefix按照大方向一樣，階層想好定下來後，不管是要新增Coustom Class，或是要在<code>Storyboard</code>上標註對應的<code>Storyboard Identifier</code>都很方便，之後再開發與維護上會因為也脈絡可循的命名而容易許多。</p>

<h2>多使用StackView</h2>

<p>在iOS9加入<code>StackView</code>之後，整個畫面裡面<code>Autolayout</code>所需要的<code>Constraints</code>大幅的減少很多，事實上官方也建議最好<code>Autolayout</code>任何畫面可以考慮直接用<code>StackView</code>開始。</p>

<p><code>StackView</code>的強項在於可以定義一個母區塊，讓裡面的<code>SubView</code>能Depend在母區塊的邊界上設定<code>Constraints</code>與做<code>Autolayout</code>，同時也限制這裡面的<code>StackView</code>裡的<code>SubView</code>改動不會影響到<code>StackView</code>之外的其他<code>View</code>。</p>

<p>在沒有<code>StackView</code>之前只有一個<code>RootView</code>要給整個畫面上一堆<code>SubView</code>當做參照，這樣在設計<code>Autolayout</code>上往往牽一髮動全身，一個<code>SubView</code>的更改常常就會連帶影響一大推其他的<code>View</code>。</p>

<h2>用Storyboard Reference切割不同功能的畫面</h2>

<p>比如<code>Tabbar</code>分出來的全部連到<code>Storyboard Reference</code>，或多次在不同地方會單獨<code>M  odel</code>出來的畫面要拆分出來。這樣一個團隊才可以同時協作開發多個頁面，解決了<code>Storyboard</code>一開始被大家詬病的<code>Git</code>協作問題。</p>

<h2>還有一些比較瑣碎的Tips</h2>

<h3>適時用Xib搭配Storyboard</h3>

<p>當我們有時候要自製一個小控件比如<code>Segment Control</code>，裡面的<code>Cell</code>便可以用xib。掌握住<code>initWithCoder</code>用來再<code>Storyboard</code>載入，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="no">If</span> <span class="n">you</span> <span class="n">are</span> <span class="n">loading</span> <span class="n">it</span> <span class="n">from</span> <span class="n">a</span> <span class="n">nib</span> <span class="n">file</span> <span class="p">(</span><span class="ow">or</span> <span class="n">a</span> <span class="n">storyboard</span><span class="p">),</span> <span class="ss">initWithCoder</span><span class="p">:</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="ss">initWithCoder</span><span class="p">:(</span><span class="no">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="n">aDecoder</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="o">[</span><span class="k">super</span> <span class="ss">initWithCoder</span><span class="p">:</span><span class="n">aDecoder</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">[</span><span class="nb">self</span> <span class="ss">addSubview</span><span class="p">:</span><span class="o">[[[</span><span class="no">NSBundle</span> <span class="n">mainBundle</span><span class="o">]</span> <span class="ss">loadNibNamed</span><span class="p">:</span><span class="no">NSStringFromClass</span><span class="p">(</span><span class="o">[</span><span class="nb">self</span> <span class="n">class</span><span class="o">]</span><span class="p">)</span> <span class="ss">owner</span><span class="p">:</span><span class="nb">self</span> <span class="ss">options</span><span class="p">:</span><span class="kp">nil</span><span class="o">]</span> <span class="ss">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="o">]]</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>initWithFrame</code>則是有時候不得已用Code的方式呼叫：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">-</span> <span class="p">(</span><span class="nb">id</span><span class="p">)</span><span class="ss">initWithFrame</span><span class="p">:(</span><span class="no">CGRect</span><span class="p">)</span><span class="n">frame</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="o">[</span><span class="k">super</span> <span class="ss">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="sr">//</span> <span class="no">Initialization</span> <span class="n">code</span>
</span><span class='line'>        <span class="nb">self</span><span class="o">.</span><span class="n">autoresizesSubviews</span> <span class="o">=</span> <span class="no">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>並且記得如果用Code呼叫要<code>Frame</code>，要在<code>viewDidAppear</code>這裡面做，因為根據<code>ViewController</code>這裡才是<code>Frame</code>經過<code>Autolayout</code>等計算後真正確定的地方。</p>

<h3>利用SizeClass</h3>

<p>比如轉向的需求，利用<code>Storyboard</code>的<code>SizeClass</code>在不同情境下就可以很輕易漂亮的適配出你要的螢幕Layout，比如影片橫幅要佔滿全螢幕等。</p>

<h2>Then&hellip;</h2>

<p>其實在Xcode裡面刻畫環境真的是很享受的過程，當你刻畫出的UI在<code>Storyboard</code>上跟UI出的圖一樣時，那樣的成就感很高。尤其Apple近幾年推出的<code>Autolayout</code>跟<code>SizeClass</code>其實都走在很前端的地方，給開發者很大的彈性與方便。</p>

<p>這裡也推薦這個網站Zeplin，我現在配合的設計師可以很方便地更新圖給大家，上面尺寸也都可以標註到很細，甚至這個網站還有Mac的APP，裡面有個特異功能是可以把素材匯進到專案的<code>Assets.xcassets</code>真的很棒！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[運用iOS Fastlane自動化部署TestFlight]]></title>
    <link href="http://sah.tw/blog/2016/05/03/ios-fastlane/"/>
    <updated>2016-05-03T14:59:51+08:00</updated>
    <id>http://sah.tw/blog/2016/05/03/ios-fastlane</id>
    <content type="html"><![CDATA[<p>老生常談得一件事情，如果一個團隊花一個禮拜的時間寫好自動部署的工具，比如用shell，把平常又臭又長或者很繁瑣的指令集結起來，之後這些繁瑣重複的工作就可以透過自動化工具省下不少時間。</p>

<blockquote><p>表面上看起來或許一年之後你才能把省下來的那幾秒鐘累積成一個禮拜，達成回本的動作，但是如果你不這樣做，你把那一個禮拜的時間打散到一年裡面，換來的就是你一年的開發效率低落。</p>

<p>長遠看來，有沒有做自動化工具的團隊，差距可謂天與地。</p></blockquote>

<p>知道了自動化的重要性，再來就iOS而言有一套<a href="https://krausefx.com/blog/fastlane-is-now-part-of-fabric">國外Twitter青年才俊高富帥工程師從side project發展成全職開發的iOS自動化工具組</a>-fastlane，國外紅一陣子了，但中文的介紹似乎不多，秉持人飢己飢的精神(?)，也方便之後回顧，就來寫這篇吧。</p>

<p>首先我會先請你到官方文件那裡安裝必要的工具，之後我在介紹你tips，讓你可以快速達到自動部署上TestFlight的要求。
當然你之後可以串接Test的流程，確認沒問題了再上TestFlight。</p>

<p>首先到<a href="https://github.com/fastlane/fastlane">Fastlane</a>的GitHub上依照最新的<code>Installation</code>章節安裝好Fastlane。接著依照<code>Quick Start</code>章節的步驟建好初步的文件。這中間可能會問你App ID啦，Apple ID的帳密呀，諸如此類的基礎設定。</p>

<p>接著看到目錄裡面的Fastfile文件，下面文件已經是我改好可以Run的版本，跟初始化的版本會不太一樣，更下面我會介紹是怎麼改過來的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>desc "Submit a new Beta Build to Apple TestFlight"
</span><span class='line'>  desc "This will also make sure the profile is up to date"
</span><span class='line'>  lane :beta do
</span><span class='line'>    increment_build_number
</span><span class='line'>    # match(type: "appstore") # more information: https://codesigning.guide
</span><span class='line'>    gym(scheme: "SecureMedia", use_legacy_build_api: true) # Build your app - more options available
</span><span class='line'>    pilot(team_name: "CUTE LIMITED")
</span><span class='line'>
</span><span class='line'>    # sh "your_script.sh"
</span><span class='line'>    # You can also use other beta testing services here (run `fastlane actions`)
</span><span class='line'>  end</span></code></pre></td></tr></table></div></figure>


<p>看到<code>lane :beta do</code>，代表之後我們只要下<code>fastlane beta</code>就可以指定執行一直到<code>end</code>包起來的這個區塊的動作。</p>

<p>我們先定義我們的beta要做什麼事情:<br/>
1. 把cocoapod裝一次<br/>
2. 把build號碼+1<br/>
3. 用Production的Provisioning Profiles，build一個ipa出來<br/>
4. 把這個版本送到TestFlight上，並送給tester</p>

<p>基本上如果上述都手動的話，大約要花上15分鐘左右（切換Provisioning Profiles, 上傳時間, 還有等iTunes connect處理新版build, 最後再手動送出分發測試版本到tester手上），透過自動化工具可以做到打一行指令後就可以不理了。</p>

<p>上述流程在Fastlane裡面被寫成三行，這三行的設定tips就分三項介紹</p>

<h3>increment_build_number</h3>

<p>Literally，<code>increment_build_number</code>就是自動增加build版號，別小看這個功能，以前常常是都發布出去了才發現沒有新增版號！需要配合設定Xcode參數<code>Current Project Version</code>。參照圖片或<a href="http://www.markschabacker.com/blog/2013/01/04/agvtool_with_new_projects/">這邊</a>。</p>

<p><img src="http://mrshih.github.io/images/ios-fastlane-1.png" alt="image" /></p>

<h3>gym</h3>

<p>這是幫我們產生ipa檔案的。後面跟上兩個參數<code>scheme</code>通常就是你得App名稱，<code>use_legacy_build_api</code>，則是因為<a href="https://github.com/fastlane/gym/issues/104">Xcode 7.0的上傳API更改了，所以在使用時有時候會錯</a>，這時候要改用舊的。</p>

<h3>pilot</h3>

<p>這是幫我們自動部署到TestFlight的，使用時需要加上<code>team_name</code>參數是因為筆者帳號下有兩個Team，你如果不填上這個Fastlane跑到一半就會問你，這樣自動化就沒意義了。</p>

<p>然後記得搭配pilot時，Xcode要配合在<code>info.plist</code>加上下面這個屬性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;key&gt;ITSAppUsesNonExemptEncryption&lt;/key&gt;
</span><span class='line'>&lt;false/&gt;</span></code></pre></td></tr></table></div></figure>


<p>討論串是說iTunes connect建議手動上傳要使用這個參數。相關討論在這個<a href="https://github.com/fastlane/pilot/issues/156">issue</a>頁。</p>

<h2>後記</h2>

<p>之後可以串接上Slack做完成時的顯示，再更進一步可以搭配Hubot，這樣連<code>fastlane beta</code>都省了。然後因為沒接觸CI Server，之後也可以研究兩者如何搭配。</p>

<p>其實筆者在用octopress發布文章的時候，明明指令沒幾行也硬是寫了三個shell來發布(new, preview, publish)，但實在是幫我省了很多時間，不然每次我可都要去google指令，很煩的。</p>

<p>只能說工程師的懶沒有極限，但正是這種懶造就了人類文明的進步（？）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有關製作iOS客製化Animation的詳細過程]]></title>
    <link href="http://sah.tw/blog/2016/05/01/detail-custom-ios-model-animation/"/>
    <updated>2016-05-01T03:05:19+08:00</updated>
    <id>http://sah.tw/blog/2016/05/01/detail-custom-ios-model-animation</id>
    <content type="html"><![CDATA[<h2>為何寫這篇</h2>

<p>前幾篇有寫到如何<a href="http://mrshih.github.io/blog/2016/01/08/first-presentation-flow/">製作SlideMenu</a>，大概講了cocoa framework在客製化<code>UIView</code>動畫的世界觀，這裡則寫一個手把手的詳細步驟，這樣搭配比較有感覺，不然Apple把class之間解構的這麼徹底，實在是東一個西一個的，一時之間不好下手。</p>

<h2>手把手開始</h2>

<p>0.建segue並且設立id<br/>
1.segue kind選custom<br/>
2.建立subclass(UIStoryboardSegue)<br/>
3.override perform function</p>

<blockquote><p>how to override perform function</p></blockquote>

<p>1.取得self.sourceViewController<br/>
2.取得self.destinationViewController<br/>
3.set destVC 的setModalPresentationStyle = UIModalPresentationCustom//顯示面積客製化<br/>
4.誰提供客製化的資訊呢？在這裡！ 建立一格subclass UIViewControllerTransitioningDelegate class(裡面怎麼實作請看段A)<br/>
5.set第四步的步驟為destVC的TransitioningDelegate<br/>
6.srcVC presentViewController destVC，動畫animated設置為YES</p>

<h2>段A</h2>

<blockquote><p>hwo to create a subclass <code>UIViewControllerTransitioningDelegate</code> 的object。</p>

<p>這裡就是實作perform跟dismiss的時候動畫要怎麼走的地方，還有系統要<code>UIPresentationController</code>的地方，簡單來說就是系統從這邊獲取怎麼客製化顯示範圍與顯示動畫的資訊。</p></blockquote>

<ul>
<li>1.提供override下面方法</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(UIViewController *)presenting sourceViewController:(UIViewController *)source{
</span><span class='line'>
</span><span class='line'>1.透過if ([presented isKindOfClass:AlbumMenuViewController class])來分別要提供對應PresentationController{
</span><span class='line'>2.建立一個subclass UIPresentationController的class。(怎麼建請看段B)
</span><span class='line'>3.透過UIPresentationController的父方法initWithPresentedViewController...(略)去instance這個PresentationController object。
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2.override下面方法來提供prestedVC顯示時的動畫物件animator(從哪裡移動到哪裡，所以其實最後prestedVC的x,y是由這裡提供的動畫物件決定)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id&lt;UIViewControllerAnimatedTransitioning&gt; _Nullable)animationControllerForPresentedController:(UIViewController * _Nonnull)presented presentingController:(UIViewController * _Nonnull)presenting sourceController:(UIViewController * _Nonnull)source{
</span><span class='line'>
</span><span class='line'>1.用if去知道你等等要回傳那個對應的animator
</span><span class='line'>if([presented isKindOfClass:[HelperTableViewController class]]){
</span><span class='line'>2.SlideMenuAnimator *animator = [[SlideMenuAnimator alloc]init];//製作一個實作UIViewControllerAnimatedTransitioning協議的animator class，怎麼做看段C
</span><span class='line'>3.[animator setPresenting:YES];// 我設計的animator可以同時包含出場與離場的動畫，這樣就不用寫兩個animator了，所以裡面有個參數可以選擇要回傳哪種動畫，這裡是出場就設定YES。
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3.override下面方法來提供prestedVC dismiss時的動畫，功能如上，決定哪裡到哪裡</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id&lt;UIViewControllerAnimatedTransitioning&gt; _Nullable)animationControllerForDismissedController:(UIViewController * _Nonnull)dismissed{
</span><span class='line'>1.用if去知道你等等要回傳那個對應的animator
</span><span class='line'>if([presented isKindOfClass:[HelperTableViewController class]]){
</span><span class='line'>2.SlideMenuAnimator *animator = [[SlideMenuAnimator alloc]init];//前面解釋過
</span><span class='line'>3.[animator setPresenting:NO];//前面解釋過
</span><span class='line'>}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>段B</h2>

<ul>
<li>1.override &ndash; <code>frameOfPresentedViewInContainerView</code>這個方法來指定prestenVC要顯示的&#8221;大小&#8221;，注意不包含位置(x,y)喔</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(CGRect)frameOfPresentedViewInContainerView
</span><span class='line'>{
</span><span class='line'>CGRect presentedViewFrame = CGRectZero;//我們要回傳的數值
</span><span class='line'>CGRect containerBounds = [[self containerView] bounds];//得到prestingVC的bounds
</span><span class='line'>// 到這裡你已經可以運加減乘除算出你要顯示的VC的大小，下面示範的是要根據ipad跟iphone做特別處理的做法
</span><span class='line'>
</span><span class='line'>if (self.traitCollection.userInterfaceIdiom == UIUserInterfaceIdiomPhone) {
</span><span class='line'>presentedViewFrame.size = CGSizeMake(floorf(containerBounds.size.width * 0.75),
</span><span class='line'>containerBounds.size.height);
</span><span class='line'>}else if(self.traitCollection.userInterfaceIdiom == UIUserInterfaceIdiomPad){
</span><span class='line'>presentedViewFrame.size = CGSizeMake(floorf(300),
</span><span class='line'>containerBounds.size.height);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>return presentedViewFrame;//最後當然是回傳
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>補充：<br/>
除了override上面的方法去指定顯示大小外，你還可以override一些方法動態的去新增或拿掉view，比如切換VC時，prested如果沒有蓋滿presting，則剩下的地方可以放上一層黑色半透明的view來做區別。<br/>
下面是範例:</p></blockquote>

<ul>
<li>2.新增<code>property @property (nonatomic) UIView *dimmingView;</code></li>
<li>3.複寫下面兩個方法，一個是當要切換時做什麼，另一個是當要隱藏時做什麼。搭配起來就可以動態新增刪除陰影view</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)presentationTransitionWillBegin {
</span><span class='line'>
</span><span class='line'>self.dimmingView = [[UIView alloc]init];
</span><span class='line'>[self.dimmingView setFrame:self.containerView.frame];
</span><span class='line'>[self.dimmingView setBackgroundColor:[UIColor blackColor]];
</span><span class='line'>[self.dimmingView setAlpha:0.3f];
</span><span class='line'>
</span><span class='line'>// Add a custom dimming view behind the presented view controller's view
</span><span class='line'>[[self containerView] addSubview:self.dimmingView];
</span><span class='line'>[self.dimmingView addSubview:[[self presentedViewController] view]];
</span><span class='line'>
</span><span class='line'>#pragma clang diagnostic push
</span><span class='line'>#pragma clang diagnostic ignored "-Wundeclared-selector"
</span><span class='line'>UITapGestureRecognizer *dimmingViewSingleTap =
</span><span class='line'>[[UITapGestureRecognizer alloc] initWithTarget:self.presentingViewController
</span><span class='line'>action:@selector(handleDimmingViewSingleTap)];
</span><span class='line'>#pragma clang diagnostic pop
</span><span class='line'>[self.dimmingView addGestureRecognizer:dimmingViewSingleTap];
</span><span class='line'>
</span><span class='line'>// Fade in the dimming view during the transition.
</span><span class='line'>[self.dimmingView setAlpha:0.0];
</span><span class='line'>// Use the transition coordinator to set up the animations.
</span><span class='line'>[[[self presentingViewController] transitionCoordinator] animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt;  _Nonnull context) {
</span><span class='line'>[self.dimmingView setAlpha:0.55];
</span><span class='line'>} completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt;  _Nonnull context) {
</span><span class='line'>
</span><span class='line'>}];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>在dismiss做一些額外coustom的事情，在這裡用讓dimmingView淡出來當例子</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)dismissalTransitionWillBegin {
</span><span class='line'>[[[self presentingViewController] transitionCoordinator] animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt;  _Nonnull context) {
</span><span class='line'>[self.dimmingView setAlpha:0.0];
</span><span class='line'>} completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt;  _Nonnull context) {
</span><span class='line'>
</span><span class='line'>}];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>段C</h2>

<ul>
<li>4.override下面方法，可以拿來改變一些基於class size變化的改變。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator 
</span><span class='line'>
</span><span class='line'>//製作實作UIViewControllerAnimatedTransitioning協議的animator，系統會去這裡要VC的初始位置跟Final位置，系統再去補齊動畫。
</span><span class='line'>//1 override 下面function來提供動畫內容（兩個位置）
</span><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt; _Nonnull)transitionContext {
</span><span class='line'>1.// 主畫布
</span><span class='line'>UIView *containerView = [transitionContext containerView];
</span><span class='line'>
</span><span class='line'>2.// 對進場來說（toVC是prestedVC），拿到後可以再去拿VC的view
</span><span class='line'>UIViewController *toVC   = [transitionContext
</span><span class='line'>viewControllerForKey:UITransitionContextToViewControllerKey];
</span><span class='line'>
</span><span class='line'>3.// 對進場來說（fromVC是prestingVC)，拿到後可以再去拿VC的view
</span><span class='line'>UIViewController *fromVC = [transitionContext
</span><span class='line'>viewControllerForKey:UITransitionContextFromViewControllerKey];
</span><span class='line'>
</span><span class='line'>4.//取得view，後面動畫主要就是都在操作這裡
</span><span class='line'>UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey];
</span><span class='line'>UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];
</span><span class='line'>
</span><span class='line'>5.//取得兩個VC的最終大小，大小是在frameOfPresentedViewInContainerView決定。
</span><span class='line'>// Set up some variables for the animation.
</span><span class='line'>CGRect containerFrame = containerView.frame;
</span><span class='line'>CGRect toViewStartFrame = [transitionContext initialFrameForViewController:toVC];
</span><span class='line'>CGRect fromViewStartFrame = [transitionContext initialFrameForViewController:fromVC];
</span><span class='line'>CGRect toViewFinalFrame = [transitionContext finalFrameForViewController:toVC];
</span><span class='line'>CGRect fromViewFinalFrame = [transitionContext finalFrameForViewController:fromVC];
</span><span class='line'>
</span><span class='line'>6.// 開始作畫 Add toVC's view to containerView
</span><span class='line'>// 把toView加進來
</span><span class='line'>[containerView addSubview:toView];
</span><span class='line'>
</span><span class='line'>7.//決定一開始的frame
</span><span class='line'>if (self.presenting) {
</span><span class='line'>//這邊直接用預設的
</span><span class='line'>CGSize size = toViewFinalFrame.size;
</span><span class='line'>[toView setFrame:CGRectMake(0, containerFrame.size.height+toViewFinalFrame.size.height, size.width, size.height)];//size一樣。x=0,y=總高度+toView的高
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//決定最終的frame
</span><span class='line'>if (self.presenting) {
</span><span class='line'>[UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
</span><span class='line'>//大小一樣。位置就只要到x=0, y=總高度-toView高度
</span><span class='line'>CGSize size = toViewFinalFrame.size;
</span><span class='line'>CGPoint point = CGPointMake(0, containerFrame.size.height-toViewFinalFrame.size.height);
</span><span class='line'>[toView setFrame:CGRectMake(point.x, point.y, size.width, size.height)];
</span><span class='line'>}completion:^(BOOL finished) {
</span><span class='line'>// 3.Cleaning up and completing the transition.
</span><span class='line'>[transitionContext completeTransition:YES];
</span><span class='line'>}];
</span><span class='line'>}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>5.override來提供動畫時間</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt; _Nullable)transitionContext {
</span><span class='line'>return 0.2f;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[為什麼要當個CS工程師]]></title>
    <link href="http://sah.tw/blog/2016/04/27/why-to-be-a-cs-engineer/"/>
    <updated>2016-04-27T15:00:00+08:00</updated>
    <id>http://sah.tw/blog/2016/04/27/why-to-be-a-cs-engineer</id>
    <content type="html"><![CDATA[<p>在電腦科學的領域裡面打滾這幾年發現一件事，當你能夠橫向操縱越多領域的工具，組合出來東西往往價值會更高。比如要組合一個APP開門鎖系統橫向需要連結PHP, Python, Objective-C, HTML約四種語言，其實每一種都不用太深入，但組合出來的系統往往一般人一時半刻不了解，需要問你是怎麼兜出來得。</p>

<p>這個發現在最近開發的新應用系統也得到驗證。其實可以這麼看，新的系統往往是由過往的工具所搭建出來，賦予新名稱，創造出新功能，如此而已。每個語言與工具有擅長的地方，拿上面提到的開鎖系統為例：</p>

<blockquote><ol>
<li>Liunx+Apache+MySql+PHP+HTML = 家裡接收開鎖請求的Server</li>
<li>Raspberry Pi + Python = 負責控制馬達開鎖的模組</li>
<li>Objective-C     = 當然就負責遠端送訊號，自動感應是不是快到家了</li>
<li>ibeacon = 放在門附近負責讓手機知道自己快到家了</li>
</ol>
</blockquote>

<p>第一點其實資訊相關科技畢業基本一定要會，不然讀資訊科系真的是可惜。接下的幾點需要你能夠不怕生的上網找資料，並且學著去試試看。</p>

<h2>何謂試試看?</h2>

<p>打個比方，蜘蛛人一開始也不知道怎麼吐絲，所以他第一步不會直接把蜘蛛絲噴到摩天大樓，然後試著在大樓建拋來拋去。第一步當然是所謂的Hello, World。</p>

<p>幾乎每個工具或語言都有提供Quick start guide，你會找上這個工具就代表你應該有先上網Google過，發現這個工具可以幫你解決問題，而接下來就是照著文章去試試看。很多人不敢試是因為害怕失敗，但我想說得是每個看似風光厲害完成些什麼的工程師都是Error Message海裡面爬出來的。遇到錯誤訊息就去Google，就這麼簡單。想要什麼功能就把手弄髒去做就對了。</p>

<h2>失敗到心寒</h2>

<p>很多人其實卡死在這裡。前面說到Error的數量，確定程式設計師的力量，但要如何撐過Error海？這就要說到理想跟錢了。你為什麼選擇程式設計？</p>

<p>程式設計在可預見的30年內一定還會一直缺人，越缺越大而已，說直白的很混的可以就溫飽三餐小確幸，強的可以過得非常爽，而其他職業在未來只會被軟體吞掉而已。你選擇了這個看似高大上的行業，可以做的事情真的很多很多，幾乎是一個應許之地。你對前端沒興趣可以走後端，也可以轉資料庫，轉Hacker，轉Linux設定架設維護寫Shall&hellip;</p>

<p>做這個行業傲嬌的點應該在於對別人來說，你就像魔法師，有沒有用過星巴克QR Code掃一掃就可以付錢？Uber有搭乘過嗎？為什麼有人說Line不安全，那什麼是安全的軟體？在未來世界大家都離不開軟體，對一般人而已這一切都像是魔術，而程式設計可以了解背後資訊的流動，你可以解釋這一切magic一般的事情。強一點的之後你可以創造Magic，有這麼神奇的技能那有人願意付你錢真的是理所當然。</p>

<p>你要對自己身為魔術師感到驕傲，這幫助我在Error海裡面保持一顆赤子之心。</p>

<h2>Be傲嬌</h2>

<p>當你靠著自己得力量打造一個自豪的小系統，有人看到你的才能，你也相信自己的才能，自然而然你會得到錢，會得到自信，一切都像滾雪球一般停不下來。這個時代需要這樣的技能，選擇大於努力，跟對領域能事半功倍。</p>

<p>最後還是要補一句，學資訊系統的過程當然痛苦，但如果你物慾很強，夢想開拉風跑車，去普及島度假住水上小屋，還是一句話，你可以選擇繼續鬱卒，也可以選擇努力，花的力氣跟時間是一樣的，而程式設計這一條路可以是個方向。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Camera Design Pattern 回顧]]></title>
    <link href="http://sah.tw/blog/2016/02/05/ios-camera-design-pattern-review/"/>
    <updated>2016-02-05T15:00:00+08:00</updated>
    <id>http://sah.tw/blog/2016/02/05/ios-camera-design-pattern-review</id>
    <content type="html"><![CDATA[<h2>主題：要刪除某張照片?</h2>

<pre><code>- Beat Practice 應該要由Model做發起去通知資料已變化。比如刪除照片： 
    1.  由某個UIButton觸發Model的Delete方法
    2.  Model做處理，處理完之後去通知相關連的ViewModel去更新（Notification）
    3.  ViewModel收到needUpdate通知，去Fetch並整理資料，最後通知View Reload
</code></pre>

<p>未完&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 實作SlideMenu - 初探ViewController切換]]></title>
    <link href="http://sah.tw/blog/2016/01/08/first-presentation-flow/"/>
    <updated>2016-01-08T18:10:00+08:00</updated>
    <id>http://sah.tw/blog/2016/01/08/first-presentation-flow</id>
    <content type="html"><![CDATA[<p><img src="http://sah.tw/images/2016-01-08-first-presentation-flow.jpg" />
所有關於ViewController切換的行為基本稱做為Model，Navegation特有的Push等等也是Model的分支。 在iOS7裡面把制定切換ViewController的行為拆分成許多Class，目的是為了要降低耦合，讓Code重用度提高，比如Coustom一個切換Animation物件可以用在好幾個ViewController之間。</p>

<p>要切換ViewController你要告訴UIKit兩件事情，顯示成怎樣<code>
UIModalPresentationStyle
</code>和過場動畫<code>Animations</code>。</p>

<h2>UIModalPresentationStyle</h2>

<p><code>UIModalPresentationStyle</code>是<code>UIViewController</code>裡的參數。定義了Presented最終呈現的樣式，比如：</p>

<ul>
<li>覆蓋全螢幕類的<code>UIModalPresentationFullScreen</code></li>
<li>iPad上常見的<code>UIModalPresentationPopover</code></li>
<li><code>UIModalPresentationCurrentContext</code>指定特定ViewController去做覆蓋</li>
<li>而我們想要的Slide Menu這樣的顯示效果不是上面幾種類型的，我們就必須要Coustom一個。也就必須實作<code>TransitioningDelegate</code>來提供下面兩種物件：

<ul>
<li><code>UIPresentationController</code></li>
<li>實作<code>UIViewControllerAnimatedTransitioning</code>的Animation</li>
</ul>
</li>
</ul>


<p>兩個物件後面會提到怎麼產生。</p>

<h2>使用Segue切換View Controller</h2>

<p>用Code寫的話常見做法是在Prestenting View Controller裡面呼叫<code>presentViewController</code>。而在這個可視化當道的年代當然要配合Storyboard搭配Segue才不會在未來多螢幕適配被淘汰掉。</p>

<p>在StoryBoard裡面拉出一條Segue，並且把Kind指定成Coustom。這樣就是告訴StoryBoard我們不用UIKit內建的展示和轉場效果，要自己建立一個Subcalss<code>UIStoryboardSegue</code>的Coustom Segue物件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vi">@interface</span> <span class="no">SlideLeftCustomSegue</span> <span class="p">:</span> <span class="no">UIStoryboardSegue</span>
</span></code></pre></td></tr></table></div></figure>


<p>在這裡只要實作<code>perform</code>方法，在裡面設定：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="err">系統調用</span><span class="n">prepareForSegue</span><span class="err">就是調用這裡</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">perform</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">UIViewController</span> <span class="o">*</span><span class="n">srcViewController</span> <span class="o">=</span> <span class="p">(</span><span class="no">UIViewController</span> <span class="o">*</span><span class="p">)</span> <span class="nb">self</span><span class="o">.</span><span class="n">sourceViewController</span><span class="p">;</span>
</span><span class='line'>    <span class="no">SettingTableViewController</span> <span class="o">*</span><span class="n">destViewController</span> <span class="o">=</span> <span class="p">(</span><span class="no">SettingTableViewController</span> <span class="o">*</span><span class="p">)</span> <span class="nb">self</span><span class="o">.</span><span class="n">destinationViewController</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">SlideMenuShowTransition</span> <span class="o">*</span><span class="n">trainstionDelegate</span> <span class="o">=</span> <span class="o">[[</span><span class="no">SlideMenuShowTransition</span> <span class="n">alloc</span><span class="o">]</span><span class="n">init</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[</span><span class="n">destViewController</span> <span class="ss">setTd</span><span class="p">:</span><span class="n">trainstionDelegate</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="sr">//</span><span class="err">把</span><span class="no">Presented</span> <span class="no">View</span> <span class="no">Controller</span><span class="err">的</span><span class="sb">`ModalPresentationStyle屬性改成UIModalPresentationCustom</span>
</span><span class='line'><span class="sb">    [destViewController setModalPresentationStyle:UIModalPresentationCustom];</span>
</span><span class='line'><span class="sb">    </span>
</span><span class='line'><span class="sb">    //設置TransitioningDelegate。這個代理主要用來提供待會兒切換會用到的所有物件。下面會介紹到</span>
</span><span class='line'><span class="sb">    [destViewController setTransitioningDelegate:trainstionDelegate];</span>
</span><span class='line'><span class="sb">    </span>
</span><span class='line'><span class="sb">    //最後呼叫presentViewController，來呼叫UIKit做開始切換</span>
</span><span class='line'><span class="sb">    [srcViewController presentViewController:destViewController animated:YES completion:nil];</span>
</span><span class='line'><span class="sb">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>TransitioningDelegate</h2>

<p>當系統發現Predented View Controller指定<code>ModalPresentationStyle</code>參數為<code>UIModalPresentationCustom</code>時，就會去呼叫<code>TransitioningDelegate</code>來提供上面有提到Model切換轉場所需的相關物件：<code>UIPresentationController</code>與Animation。</p>

<p>只要創一個實作<code>TransitioningDelegate</code>的NSObject，並指定給Presented View Controller就可以了。</p>

<p>執行的時候UIKit會先抓UIPresentaionController再依照情況抓取要的Animaion物件。</p>

<ol>
<li>提交<code>UIPresentaionController</code>來決定Presented View的Final的Frame。</li>
<li>提交所有轉場，包誇Present View Controller進來, Dismiss View Controller，還有交互等等。我們這裡簡單討論Present還有Dismiss的Animation物件怎麼做。</li>
</ol>


<p>系統會先抓<code>UIPresentaionController</code>一部分是因為Animation物件需要知道Prested View Final Frame。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="n">present</span><span class="err">時</span><span class="n">uikit</span><span class="err">會從這裡拿資料</span><span class="o">&lt;</span><span class="err">過場動畫</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">UIViewControllerAnimatedTransitioning</span><span class="o">&gt;</span> <span class="n">_Nullable</span><span class="p">)</span><span class="ss">animationControllerForPresentedController</span><span class="p">:(</span><span class="no">UIViewController</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="n">presented</span> <span class="ss">presentingController</span><span class="p">:(</span><span class="no">UIViewController</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="n">presenting</span> <span class="ss">sourceController</span><span class="p">:(</span><span class="no">UIViewController</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="n">source</span> <span class="p">{</span>
</span><span class='line'>    <span class="no">SlideMenuAnimator</span> <span class="o">*</span><span class="n">animator</span> <span class="o">=</span> <span class="o">[[</span><span class="no">SlideMenuAnimator</span> <span class="n">alloc</span><span class="o">]</span><span class="n">init</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[</span><span class="n">animator</span> <span class="ss">setPresenting</span><span class="p">:</span><span class="no">YES</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">animator</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="sr">//</span> <span class="n">dismiss</span><span class="err">時</span><span class="n">uikit</span><span class="err">會從這裡拿資料</span><span class="o">&lt;</span><span class="err">過場動畫</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">UIViewControllerAnimatedTransitioning</span><span class="o">&gt;</span> <span class="n">_Nullable</span><span class="p">)</span><span class="ss">animationControllerForDismissedController</span><span class="p">:(</span><span class="no">UIViewController</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="n">dismissed</span> <span class="p">{</span>
</span><span class='line'>    <span class="no">SlideMenuAnimator</span> <span class="o">*</span><span class="n">animator</span> <span class="o">=</span> <span class="o">[[</span><span class="no">SlideMenuAnimator</span> <span class="n">alloc</span><span class="o">]</span><span class="n">init</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[</span><span class="n">animator</span> <span class="ss">setPresenting</span><span class="p">:</span><span class="no">NO</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">animator</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="sr">//</span> <span class="no">UIKit</span><span class="err">在切換之初從這裡要</span><span class="no">UIPresentationController</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="no">UIPresentationController</span> <span class="o">*</span><span class="p">)</span><span class="ss">presentationControllerForPresentedViewController</span><span class="p">:</span>
</span><span class='line'><span class="p">(</span><span class="no">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">presented</span>
</span><span class='line'>                                                      <span class="ss">presentingViewController</span><span class="p">:(</span><span class="no">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">presenting</span>
</span><span class='line'>                                                          <span class="ss">sourceViewController</span><span class="p">:(</span><span class="no">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">source</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">SlideMenuPresentaionController</span><span class="o">*</span> <span class="n">myPresentation</span> <span class="o">=</span> <span class="o">[[</span><span class="no">SlideMenuPresentaionController</span> <span class="n">alloc</span><span class="o">]</span>
</span><span class='line'>                                                <span class="ss">initWithPresentedViewController</span><span class="p">:</span><span class="n">presented</span> <span class="ss">presentingViewController</span><span class="p">:</span><span class="n">presenting</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">myPresentation</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>UIPresentationController</h2>

<p>在iOS 7裡面引進了這個<code>UIPresentationController</code>，可以決定以下事情</p>

<ul>
<li>Set the size of the presented view controller.</li>
<li>Add custom views to change the visual appearance of the presented content.</li>
<li>Supply transition animations for any of its custom views.</li>
<li>Adapt the visual appearance of the presentation when changes occur in the app’s environment.（之後另設補充）</li>
</ul>


<p>這裡只先介紹前三項，指定Presented View Frame的方法，還有額外增加Coustom View如陰影層的方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="err">決定了使用</span><span class="no">UIModalPresentationCustom</span><span class="err">這樣的</span><span class="no">Model</span><span class="err">切換方式，就可以在這裡直接指定</span><span class="no">PresentedView</span><span class="err">的</span><span class="n">frame</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="no">CGRect</span><span class="p">)</span><span class="n">frameOfPresentedViewInContainerView</span> <span class="p">{</span>
</span><span class='line'>    <span class="no">CGRect</span> <span class="n">presentedViewFrame</span> <span class="o">=</span> <span class="no">CGRectZero</span><span class="p">;</span>
</span><span class='line'>    <span class="no">CGRect</span> <span class="n">containerBounds</span> <span class="o">=</span> <span class="o">[[</span><span class="nb">self</span> <span class="n">containerView</span><span class="o">]</span> <span class="n">bounds</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">presentedViewFrame</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="no">CGSizeMake</span><span class="p">(</span><span class="n">floorf</span><span class="p">(</span><span class="n">containerBounds</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="mi">0</span><span class="o">.</span><span class="mi">7</span><span class="p">),</span>
</span><span class='line'>                                         <span class="n">containerBounds</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">presentedViewFrame</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="sr">//</span> <span class="no">Present</span><span class="err">的時候可以增加一些</span><span class="no">Coustom</span> <span class="no">View</span><span class="err">，靠</span><span class="n">animateAlongsideTransition</span><span class="err">來顯示新增的</span><span class="no">Coustom</span><span class="err">過場動畫</span>
</span><span class='line'><span class="sr">//</span> <span class="err">這裡用</span><span class="n">dimmingView</span><span class="err">來做</span><span class="no">Coustom</span> <span class="no">View</span><span class="err">的例子</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">presentationTransitionWillBegin</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="o">=</span> <span class="o">[[</span><span class="no">UIView</span> <span class="n">alloc</span><span class="o">]</span><span class="n">init</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">setFrame</span><span class="p">:</span><span class="nb">self</span><span class="o">.</span><span class="n">containerView</span><span class="o">.</span><span class="n">frame</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">setBackgroundColor</span><span class="p">:</span><span class="o">[</span><span class="no">UIColor</span> <span class="n">blackColor</span><span class="o">]]</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">setAlpha</span><span class="p">:</span><span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="n">f</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Add</span> <span class="n">a</span> <span class="n">custom</span> <span class="n">dimming</span> <span class="n">view</span> <span class="n">behind</span> <span class="n">the</span> <span class="n">presented</span> <span class="n">view</span> <span class="n">controller</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">view</span>
</span><span class='line'>    <span class="o">[[</span><span class="nb">self</span> <span class="n">containerView</span><span class="o">]</span> <span class="ss">addSubview</span><span class="p">:</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">addSubview</span><span class="p">:</span><span class="o">[[</span><span class="nb">self</span> <span class="n">presentedViewController</span><span class="o">]</span> <span class="n">view</span><span class="o">]]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#pragma clang diagnostic push</span>
</span><span class='line'><span class="c1">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</span>
</span><span class='line'>    <span class="no">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">dimmingViewSingleTap</span> <span class="o">=</span>
</span><span class='line'>    <span class="o">[[</span><span class="no">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="o">]</span> <span class="ss">initWithTarget</span><span class="p">:</span><span class="nb">self</span><span class="o">.</span><span class="n">presentingViewController</span>
</span><span class='line'>                                            <span class="ss">action</span><span class="p">:</span><span class="vi">@selector</span><span class="p">(</span><span class="n">handleDimmingViewSingleTap</span><span class="p">)</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'><span class="c1">#pragma clang diagnostic pop</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">addGestureRecognizer</span><span class="p">:</span><span class="n">dimmingViewSingleTap</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Fade</span> <span class="k">in</span> <span class="n">the</span> <span class="n">dimming</span> <span class="n">view</span> <span class="n">during</span> <span class="n">the</span> <span class="n">transition</span><span class="o">.</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">setAlpha</span><span class="p">:</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Use</span> <span class="n">the</span> <span class="n">transition</span> <span class="n">coordinator</span> <span class="n">to</span> <span class="n">set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">animations</span><span class="o">.</span>
</span><span class='line'>    <span class="o">[[[</span><span class="nb">self</span> <span class="n">presentingViewController</span><span class="o">]</span> <span class="n">transitionCoordinator</span><span class="o">]</span> <span class="ss">animateAlongsideTransition</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">UIViewControllerTransitionCoordinatorContext</span><span class="o">&gt;</span>  <span class="n">_Nonnull</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">setAlpha</span><span class="p">:</span><span class="mi">0</span><span class="o">.</span><span class="mi">55</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="ss">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">UIViewControllerTransitionCoordinatorContext</span><span class="o">&gt;</span>  <span class="n">_Nonnull</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">dismissalTransitionWillBegin</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">[[[</span><span class="nb">self</span> <span class="n">presentingViewController</span><span class="o">]</span> <span class="n">transitionCoordinator</span><span class="o">]</span> <span class="ss">animateAlongsideTransition</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">UIViewControllerTransitionCoordinatorContext</span><span class="o">&gt;</span>  <span class="n">_Nonnull</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">[</span><span class="nb">self</span><span class="o">.</span><span class="n">dimmingView</span> <span class="ss">setAlpha</span><span class="p">:</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="ss">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">UIViewControllerTransitionCoordinatorContext</span><span class="o">&gt;</span>  <span class="n">_Nonnull</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Animation</h2>

<p>建立一個實作<code>UIViewControllerAnimatedTransitioning</code> protocol的<code>NSObject</code>，裡面會有系統傳入的<code>UIViewControllerContextTransitioning</code>，這裡面會包含你後面要做動畫所需的所有物件。</p>

<p>主要兩個方法，一個方法專門玩動畫，一個方法單純回傳動畫所需時間。</p>

<p>我們可以把Present和Dismiss的動畫寫在一起，但<code>transitionContext</code>傳入的資訊什麼都有，就是沒有現在是Present還是Dismiss狀態的參數。</p>

<p>所以要自己設一個，並且在<code>TransitioningDelegate</code>回傳動畫方法時指定給Animation物件知道:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vi">@interface</span> <span class="no">SlideMenuAnimator</span> <span class="p">:</span> <span class="no">NSObject</span><span class="o">&lt;</span><span class="no">UIViewControllerAnimatedTransitioning</span><span class="o">&gt;</span>
</span><span class='line'><span class="vi">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="no">Boolean</span> <span class="n">presenting</span><span class="p">;</span>
</span><span class='line'><span class="vi">@end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="err">這裡</span><span class="no">UIKit</span><span class="err">會給我們兩個</span><span class="no">View</span><span class="err">，包在</span><span class="n">transitionContext</span><span class="err">裡面，只要取出來玩就好了</span>
</span><span class='line'><span class="sr">//</span> <span class="err">這裡是真的作動畫的地方</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="ss">animateTransition</span><span class="p">:(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">UIViewControllerContextTransitioning</span><span class="o">&gt;</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="n">transitionContext</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Get</span> <span class="n">the</span> <span class="n">set</span> <span class="n">of</span> <span class="n">relevant</span> <span class="n">objects</span><span class="o">.</span>
</span><span class='line'>    <span class="no">UIView</span> <span class="o">*</span><span class="n">containerView</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span> <span class="n">containerView</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="no">UIViewController</span> <span class="o">*</span><span class="n">fromVC</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span>
</span><span class='line'>                                <span class="ss">viewControllerForKey</span><span class="p">:</span><span class="no">UITransitionContextFromViewControllerKey</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="no">UIViewController</span> <span class="o">*</span><span class="n">toVC</span>   <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span>
</span><span class='line'>                                <span class="ss">viewControllerForKey</span><span class="p">:</span><span class="no">UITransitionContextToViewControllerKey</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">UIView</span> <span class="o">*</span><span class="n">toView</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span> <span class="ss">viewForKey</span><span class="p">:</span><span class="no">UITransitionContextToViewKey</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="no">UIView</span> <span class="o">*</span><span class="n">fromView</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span> <span class="ss">viewForKey</span><span class="p">:</span><span class="no">UITransitionContextFromViewKey</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Set</span> <span class="n">up</span> <span class="n">some</span> <span class="n">variables</span> <span class="k">for</span> <span class="n">the</span> <span class="n">animation</span><span class="o">.</span>
</span><span class='line'>    <span class="sr">//</span><span class="no">CGRect</span> <span class="n">containerFrame</span> <span class="o">=</span> <span class="n">containerView</span><span class="o">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="sr">//</span><span class="no">CGRect</span> <span class="n">toViewStartFrame</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span> <span class="ss">initialFrameForViewController</span><span class="p">:</span><span class="n">toVC</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="no">CGRect</span> <span class="n">fromViewStartFrame</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span> <span class="ss">initialFrameForViewController</span><span class="p">:</span><span class="n">fromVC</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="no">CGRect</span> <span class="n">toViewFinalFrame</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span> <span class="ss">finalFrameForViewController</span><span class="p">:</span><span class="n">toVC</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="no">CGRect</span> <span class="n">fromViewFinalFrame</span> <span class="o">=</span> <span class="o">[</span><span class="n">transitionContext</span> <span class="ss">finalFrameForViewController</span><span class="p">:</span><span class="n">fromVC</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="sr">//</span> <span class="mi">3</span><span class="o">.</span> <span class="no">Add</span> <span class="n">toVC</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">view</span> <span class="n">to</span> <span class="n">containerView</span>
</span><span class='line'>    <span class="o">[</span><span class="n">containerView</span> <span class="ss">addSubview</span><span class="p">:</span><span class="n">toView</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">presenting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">[</span><span class="n">toView</span> <span class="ss">setFrame</span><span class="p">:</span><span class="no">CGRectOffset</span><span class="p">(</span><span class="n">toViewFinalFrame</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">toViewFinalFrame</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">[</span><span class="n">fromView</span> <span class="ss">setFrame</span><span class="p">:</span><span class="n">fromViewStartFrame</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Creating</span> <span class="n">the</span> <span class="n">animations</span> <span class="n">using</span> <span class="no">Core</span> <span class="no">Animation</span> <span class="ow">or</span> <span class="no">UIView</span> <span class="n">animation</span> <span class="nb">methods</span><span class="o">.</span>
</span><span class='line'>    <span class="o">[</span><span class="no">UIView</span> <span class="ss">animateWithDuration</span><span class="p">:</span><span class="o">[</span><span class="nb">self</span> <span class="ss">transitionDuration</span><span class="p">:</span><span class="n">transitionContext</span><span class="o">]</span> <span class="ss">animations</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">presenting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">toView</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">toViewFinalFrame</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fromView</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="no">CGRectOffset</span><span class="p">(</span><span class="n">fromViewFinalFrame</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">fromViewFinalFrame</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="ss">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="no">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="sr">//</span> <span class="mi">3</span><span class="o">.</span><span class="n">Cleaning</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">completing</span> <span class="n">the</span> <span class="n">transition</span><span class="o">.</span>
</span><span class='line'>        <span class="o">[</span><span class="n">transitionContext</span> <span class="ss">completeTransition</span><span class="p">:</span><span class="no">YES</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>嚴謹有序的切換View Controller Flow</h2>

<p>到這邊就可以做出一個會動，有PresentingView有陰影Mask的SlideMenu了，視覺上是仿照Google Photo。基本上iOS 7所引進的這些許多新方法都是為了要解構，使之可以更容易管理，更有邏輯性。</p>

<p>有關切換ViewController來有些重要Feature，留待之後想到應用實作再增加</p>

<ul>
<li>InteractiveTransition交互動畫的部分</li>
<li>跟<code>UIPresentationController</code>適配不同場景的應用Adapting to Different Size Classes</li>
</ul>


<h3>參考資料</h3>

<p> <a href="https://developer.apple.com/videos/play/wwdc2014-228/">https://developer.apple.com/videos/play/wwdc2014-228/</a>
&ndash; <a href="http://onevcat.com/2013/10/vc-transition-in-ios7/">http://onevcat.com/2013/10/vc-transition-in-ios7/</a>
&ndash; <a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1">https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 大量網路與硬碟I/0處理]]></title>
    <link href="http://sah.tw/blog/2016/01/04/ios-serial-queue-run-async-background-job/"/>
    <updated>2016-01-04T15:00:00+08:00</updated>
    <id>http://sah.tw/blog/2016/01/04/ios-serial-queue-run-async-background-job</id>
    <content type="html"><![CDATA[<p>很多時候操作網路或者Disk的I/O，我們都會把工作丟到背景去執行，避免凍結使用者的畫面。但是這造成一個問題是一下子太多背景任務同時執行有可能導致APP崩潰。</p>

<p>比如影音APP使用者見獵心喜，一下子選了許多部影片要下載，如果現在把下載任務一股腦兒丟到背景，因為現在大部分下載需求都直接使用知名框架<code>AFNetworking</code>，而裡面的方法通常也都直接在背景運行，造成這些下載任務用Concurrent的方式併發執行，這下子產生大量的網路還有Disk I/O Request同時在背景跑。</p>

<p>UI是不會被凍結沒錯，但很有可能背景操作網路或Disk I/O的量太多（通常是Disk），導致APP崩潰。</p>

<h2>以Serial思維執行背景任務</h2>

<p>這時候就非常建議一次下載並儲存一部影片就好。也就是確保上個任務執行完畢，Queue在推送下一個任務去執行。</p>

<h2>混亂的完成順序</h2>

<p>直觀的實作方式就是建立一個Serial Queue，把需要列隊執行的任務用<code>dispatch_async</code>加入進去，就像以下方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="err">建立一個唯一的</span><span class="no">Serial</span> <span class="no">Queue</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">_uploadToParseInBackgroundQueue</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">static</span> <span class="n">dispatch_once_t</span> <span class="n">queueCreationGuard</span><span class="p">;</span>
</span><span class='line'>    <span class="n">static</span> <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queueCreationGuard</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s2">&quot;com.shih.secureMedia.uploadToParseInBackgroundQueue&quot;</span><span class="p">,</span> <span class="no">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">queue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="sr">//</span> <span class="err">包含一個異步方法的</span><span class="no">Method</span>
</span><span class='line'><span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">addTaskUploadMovie</span><span class="p">(</span><span class="no">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="n">movie</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">_uploadToParseInBackgroundQueue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">&quot;%@上傳Start.......&quot;</span><span class="p">,</span><span class="n">movie</span><span class="o">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>    <span class="sr">//</span> <span class="err">某個很花時間，但本身已經是丟到背景處理的方法</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span> <span class="ss">uploadMovieInBackground</span><span class="p">:</span><span class="n">movie</span> <span class="ss">withCompleteBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="no">BOOL</span> <span class="n">succeeded</span><span class="p">,</span> <span class="no">NSError</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">&quot;%@上傳Done&quot;</span><span class="p">,</span><span class="n">movie</span><span class="o">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>實際執行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="nb">self</span> <span class="ss">addTaskUploadMovie</span><span class="p">:</span><span class="n">a</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'><span class="o">[</span><span class="nb">self</span> <span class="ss">addTaskUploadMovie</span><span class="p">:</span><span class="n">b</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'><span class="o">[</span><span class="nb">self</span> <span class="ss">addTaskUploadMovie</span><span class="p">:</span><span class="n">c</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'><span class="o">[</span><span class="nb">self</span> <span class="ss">addTaskUploadMovie</span><span class="p">:</span><span class="n">d</span><span class="o">]</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>這裡有個大問題是<code>uploadMovieInBackground</code>本身已經是跑在背景，所以四個上傳任務實際上在後台是以併發Concurrent/Parallel的方式執行。</p>

<p>而多個高I/0負載任務被同時執行就有可能造成APP崩潰。</p>

<p>實際執行結果會像這樣，但實際上不可預測，因為不能知道哪個會先完成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">b</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">a</span><span class="err">上傳</span><span class="no">Done</span>
</span><span class='line'><span class="n">c</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">c</span><span class="err">上傳</span><span class="no">Done</span>
</span><span class='line'><span class="n">d</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">d</span><span class="err">上傳</span><span class="no">Done</span>
</span><span class='line'><span class="n">b</span><span class="err">上傳</span><span class="no">Done</span>
</span></code></pre></td></tr></table></div></figure>


<h2>可控制的完成順序</h2>

<p>而如果你希望上傳程序按照以下Serial的邏輯去跑:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">a</span><span class="err">上傳</span><span class="no">Done</span>
</span><span class='line'><span class="n">b</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">b</span><span class="err">上傳</span><span class="no">Done</span>
</span><span class='line'><span class="n">c</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">c</span><span class="err">上傳</span><span class="no">Done</span>
</span><span class='line'><span class="n">d</span><span class="err">上傳</span><span class="no">Start</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="n">d</span><span class="err">上傳</span><span class="no">Done</span>
</span></code></pre></td></tr></table></div></figure>


<h3>加入<code>dispatch_suspend</code>與<code>dispatch_resume</code></h3>

<p>加入這兩個操控Queue的方法就是做兩個目的：</p>

<ul>
<li><p>當某個在Serial Queue的上傳任務Block被執行的時候，此任務在Block內馬上呼叫Queue的Suspend方法，來暫停這個Queue繼續執行下個上傳任務</p></li>
<li><p>而當前上傳任務執行完成之後，在該任務的call back block裡面馬上呼叫Queue的Resume，來讓下個上傳任務被執行</p></li>
</ul>


<p>反覆上述行為就達到我們要的一次在背景做一件事情的效果了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">addTaskUploadMovie</span><span class="p">(</span><span class="no">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="n">movie</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">_uploadToParseInBackgroundQueue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">&quot;%@上傳Start.......&quot;</span><span class="p">,</span><span class="n">movie</span><span class="o">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>    <span class="sr">//</span> <span class="err">某個很花時間，但本身已經是丟到背景處理的</span><span class="n">metod</span>
</span><span class='line'>    <span class="o">[</span><span class="nb">self</span> <span class="ss">uploadMovieInBackground</span><span class="p">:</span><span class="n">movie</span> <span class="ss">withCompleteBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="no">BOOL</span> <span class="n">succeeded</span><span class="p">,</span> <span class="no">NSError</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">&quot;%@上傳Done&quot;</span><span class="p">,</span><span class="n">movie</span><span class="o">.</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="sr">//</span> <span class="err">這個</span><span class="no">Task</span><span class="err">執行完了，讓</span><span class="no">Queue</span> <span class="n">resume</span><span class="err">，讓排在下一個的</span><span class="no">Task</span><span class="err">可以被執行</span>
</span><span class='line'>        <span class="n">dispatch_resume</span><span class="p">(</span><span class="n">_uploadToParseInBackgroundQueue</span><span class="p">());</span>
</span><span class='line'>    <span class="p">}</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="sr">//</span> <span class="err">上面的</span><span class="n">uploadMovieInBackground</span><span class="err">開始後，就暫停這個</span><span class="no">Queue</span><span class="err">，不再執行</span><span class="no">Task</span><span class="p">(</span><span class="err">外部依然可以隨時用</span><span class="n">dispatch_async</span> <span class="no">Passing</span> <span class="no">Task</span><span class="p">)</span>
</span><span class='line'>    <span class="n">dispatch_suspend</span><span class="p">(</span><span class="n">_uploadToParseInBackgroundQueue</span><span class="p">());</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW14">dispatch_resume與dispatch_suspend的官方參考文件</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推播結合背景更新 - 良好的使用者體驗]]></title>
    <link href="http://sah.tw/blog/2015/12/22/ios-background-mode-notification/"/>
    <updated>2015-12-22T20:36:49+08:00</updated>
    <id>http://sah.tw/blog/2015/12/22/ios-background-mode-notification</id>
    <content type="html"><![CDATA[<p>試想一個情境是相簿APP在後台收到伺服器傳來愛人分享的最新照片，但使用者興沖沖的打開之後面對轉阿轉不停的Loading indicator圓圈圈，多麼令人掃興。 動通知但被動下載資料顯然不是一個好方法。</p>

<p>這個時候可以透過推播通知APP，並在背景讓程式預載相片，載好之後再通知使用者點開APP，立即可以看到所有相片，多棒的使用者體驗。</p>

<p>要不打擾到使用者偷偷通知手機要實作<code>Silent Notification</code>，很簡單，只要加上<code>content-available=1</code>，再來把<code>alert</code>,<code>badge</code>,<code>sound</code>全部留空就好，並且在Xcode的Capabilities->Background Modes->Remotes Notification這裡把選項打勾。</p>

<p>這時候當手機收到有<code>content-available=1</code>的推播，iOS就會在背景喚醒你的APP，並且呼叫下面方法讓你下載資料或做些事，下次使用者打開就可以看到更新的內容了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="ss">application</span><span class="p">:(</span><span class="no">UIApplication</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="n">application</span> <span class="ss">didReceiveRemoteNotification</span><span class="p">:(</span><span class="no">NSDictionary</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="n">userInfo</span> <span class="ss">fetchCompletionHandler</span><span class="p">:(</span><span class="n">void</span> <span class="p">(</span><span class="o">^</span> <span class="n">_Nonnull</span><span class="p">)(</span><span class="no">UIBackgroundFetchResult</span> <span class="n">result</span><span class="p">))</span><span class="n">handler</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="sr">//</span> <span class="err">下載資料</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'>  <span class="sr">//</span> <span class="no">Local</span> <span class="no">Notification</span><span class="err">提示使用者下載好囉</span>
</span><span class='line'>  <span class="no">UILocalNotification</span> <span class="o">*</span><span class="n">locNotification</span> <span class="o">=</span> <span class="o">[[</span><span class="no">UILocalNotification</span> <span class="n">alloc</span><span class="o">]</span> <span class="n">init</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">locNotification</span><span class="o">.</span><span class="n">alertBody</span> <span class="o">=</span> <span class="err">@</span><span class="s2">&quot;Data have arrived!&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="o">[[</span><span class="no">UIApplication</span> <span class="n">sharedApplication</span><span class="o">]</span><span class="ss">presentLocalNotificationNow</span><span class="p">:</span><span class="n">locNotification</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="sr">//</span><span class="err">回調系統下載好了</span>
</span><span class='line'>  <span class="n">handler</span><span class="p">(</span><span class="no">UIBackgroundFetchResultNewData</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>&hellip;the system launches your app (or wakes it from the suspended state) and puts it in the background state when a remote notification arrives. However, the system does not automatically launch your app if the user has force-quit it. In that situation, the user must relaunch your app or restart the device before the system attempts to launch your app automatically again&hellip;&hellip;</p>

<p>As soon as you finish processing the notification, you must call the block in the handler parameter or your app will be terminated. Your app has up to 30 seconds of wall-clock time to process the notification and call the specified completion handler block&hellip;.</p></blockquote>

<p>官方文件說有例外，就是使用者曾經手動殺掉過這個APP，奇怪的是在我的開發經驗裡面，就算使用者手動殺掉系統在收到推播之後還是會去喚醒這個APP。</p>

<p>然後系統大約會給你30的時間讓你去下載需要的資料到記憶體或硬碟，之後就必須要call handler<code>UIBackgroundFetchResult</code>告訴系統已經載入完畢。</p>

<p>如果成功下載了我們要的資料，就可以發一個LocalNotification來通知使用者來享用你剛下載好的檔案，一打開就有下載好的內容，多棒的使用者體驗啊。</p>
]]></content>
  </entry>
  
</feed>
