<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MR SHIH]]></title>
  <link href="http://sah.tw/atom.xml" rel="self"/>
  <link href="http://sah.tw/"/>
  <updated>2017-12-12T08:14:30+08:00</updated>
  <id>http://sah.tw/</id>
  <author>
    <name><![CDATA[施安宏]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[工作價值衡量]]></title>
    <link href="http://sah.tw/blog/2017/12/12/work-performance/"/>
    <updated>2017-12-12T08:10:01+08:00</updated>
    <id>http://sah.tw/blog/2017/12/12/work-performance</id>
    <content type="html"><![CDATA[<p>年終又到了，過去一年你是如何評價自己的工作產出？</p>

<p>今天你是一位專案經理，你在一場同業聚會上自我介紹上說：『我平時會協助客戶進行需求評估，給予專業之專案規劃說明書，並且跨部門溝通協調專案在時間內完成』。ok，這樣乍聽之下沒有問題，但盲點在於如果這時你的另一位同業說：『我今手的專案總金額達3000萬以上，客戶皆為台灣知名銀行，並且都能提前交件，節省成本達10%，其中60%為人力成本。處理過10個專案，並且都成功如期結案』。如果你是老闆你要用那一位呢？</p>

<p>第一位只是敘述了他的職位說明，任何一位差不多年資的專案經理，工作內容應該都是差不多的，大家都做了差不多的事，你有什麼不同？而第二位則把重點擺在具體的亮點與實際的貢獻，比如知名公司、專案規模大小與總結案金額等。Let me put it in this way，讓對方自動從你做過的豐功偉業中去得出你有能力且很專業的結論。</p>

<p>這讓我們學到什麼呢？平時工作上要一直問自己，我正在做的事的實際貢獻是什麼？成果、績效 、里程碑。對業務來說就是你的業績與合約金額、成交數與客戶數等。對技術來說就是你的專案規模、複雜度與金額。這些都是可以用數字很明確的衡量出得價值。</p>

<p>定期的去把這些事情記錄下來，比如負責某專案，其時間、金額與你在這個專案中貢獻等。能數字化就數字化。如果你整理不出來呢？那就要好好檢視一下自己是否能去主動爭取相關機會，如爭取有實際可量化貢獻或成就的事情來做。</p>

<p>又到了實際行動的時間，從現在開始定期盤點自己的職涯成就吧，2 month basis。格式就如以下，一筆一筆的記錄下來：</p>

<ul>
<li>期間：2017-5 ~ 2017-10</li>
<li>公司/職位/專案：xx科技/專案經理/xx銀行xx案</li>
<li>tag</li>
<li>成就/貢獻/產出:

<ul>
<li>帶領2位工程師以及1業務人員完成專案，金額400萬</li>
<li>戰略專案，幫助公司獲得該銀行資安主要系統地位</li>
<li>成功複製沿用產品，達到資源重複使用，利潤提高50%</li>
<li>幫助公司排除競爭者，繼續獨家提供設備給予廠商</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[職場做好事情的判斷力]]></title>
    <link href="http://sah.tw/blog/2017/11/22/office-partnership/"/>
    <updated>2017-11-22T15:47:34+08:00</updated>
    <id>http://sah.tw/blog/2017/11/22/office-partnership</id>
    <content type="html"><![CDATA[<h2>判斷力的缺乏</h2>

<p> 公司現在正在進行產業升級，要從硬體跨足軟體平台，老闆很重視軟體，認為是未來提升營收的成長動能，也是公司在市場攻城掠地擴大市佔率的重要戰略工具，但合作的同事或底下的部署尚不清楚公司目標，把軟體研發的工作視為<strong>&lsquo;額外&rsquo;</strong>的工作，認為原本硬體工作做好就好，學習軟體的部分是多餘的，為什麼我要學？</p>

<p>但是硬體部份其實賣出去剩下都是維護，在老闆眼中只是例行性工作，就算出狀況要聯絡原廠也只算是緩衝工作，把大部分時間挪去聯絡原廠解決問題，然後覺得自己不被重視（可能硬體維護的錢公司常常公開說很重視，導致認為此事在老闆眼中很重要，但老闆<strong>只在意業務有沒有談高維護合約的錢而已</strong>，技術部你處理維護好只是<strong>領薪水份內的事</strong>）。</p>

<h4>應用</h4>

<p>上了課之後，學會以後跟部署說明工作有分緩衝工作跟核心工作，不要只是把時間都拿去處理緩衝工作，高風險低報酬，然後覺得自己明明努力在做維護，公司還虧待自己。</p>

<p>老闆常常說維護很重要，是指維護的錢老闆覺得很重要，所以在業務部那是核心工作或根本是形象工作，在技術部，維護偏向緩衝工作。</p>

<p>所以大家要把時間跟精力，放在研發新軟體上，這樣老闆對你的態度自然會變，會重視你。薪水 職位 尊重那些自然會來。</p>

<h2>對局的不認識</h2>

<p>自己之前常常搞不懂老闆一直逼我們pre-sales出去簡報的時候，為什麼要積極的去換名片？不就簡報完叫業務去問有沒有興趣就好了，真的出問題再找業務去聯絡技術窗口，接著我們再來接手。我們技術人員就還是趕快簡報完回去開發程式比較重要。</p>

<h4>應用</h4>

<p>跟我有同樣想法的技術人員幾乎是全部，都覺得跟客戶換名片沒什麼意義。但上了這次課之後搭配以前的情境恍然大悟，也知道以後怎麼跟同事講換名片（搞懂title, 搞懂對方在這個案子力扮演的角色）的重要性了。</p>

<p>就技術面來說，產品賣出去真的出問題，第一時間要是可以找到working-level的人，那就能很快地了解狀況。說不定對方還能幫我們現場做一些除錯，問題就直接解決了。</p>

<p>業務面來說，而我們pre-sales成案也是有獎金，如果我能搞懂可能那些人是真正要使用的人（常常業務對口只是負責採購設備的單位），並與他建立關係，會後直接附上更多參考訊息，並且看對方的回饋態度，其實有沒有機會成案搞不好很容易就觀察出來，不用事後還白忙很多場，甚至因為主動聯絡真正要使用的人，成案的機會都會提升。</p>

<p>以後我就完全知道出去換名片的意義，因為能對整個局更加了解，找出真正重要的關係人！以後部署出去做pre-sales也才好說服他們換名片，知道出去簡報重點在哪裡，搜集問題，搜集人的資訊，搞懂局！</p>

<p>我也可以分享給老闆怎麼讓底下的人了解交換名片認識人的重要性，這樣他們才會實際去做！</p>

<h2>對上位者需求的不理解</h2>

<p>常常老闆會莫名其妙跑出不可行的idea，我都會直接說為什麼不可能，雖然老闆事後會理解不可行（應該吧&hellip;因為沒再提了），但當下都會有一些爭論。</p>

<h4>應用</h4>

<p>了解應該去滿足老闆有效掌控的慾望後就知道，先思考老闆背後動機是什麼，比如業績提升（感覺是TOC核心目標），他心裡面想被滿足什麼，產品支援度提升，自己得意見被思考（感覺是TOC內心需求），然後第一時間不急著反駁老闆的對外訴求，表示對於大方向，比如支援度提升認同，然後再說我們會去研究老闆的對外訴求。</p>

<p>上完課後第一個工作日老闆來跟我產品應該增加A功能，我就學乖了，先說『沒錯，應該要提升對於這個功能的支援度，這樣才有辦法做xxx，我們會去研究看看A功能整合上有沒有問題』，當下老闆就沒有再打斷我們工作了。事後我們再提其他解法就可以了（如果老闆還記得&hellip;），畢竟滿足內心需求有很多種做法！</p>

<h2>心中沒有指南針，浪來會亂飄</h2>

<p>自己對於工作與產出是個很有責任感的人，對於專案的輕重緩急因為有上過專案管理啟蒙也有判斷力，公司業務都很喜歡與我合作。但有時日常生活的消耗時間，專案或技術或市場推行碰到阻力，一陣子沒有進展，或是不明原因，有時會有種好像不小心庸庸碌碌不知道自己在幹嘛的感覺。</p>

<h4>應用</h4>

<p>像今天在猶豫要不要跟大家出去買飯吃，平常大家會揪但我心裡是不太想的，中午時間喜歡快速解決，然後繼續工作。但今天轉念想到老師上課三不五時就會指的『你想從工作中獲的什麼』的那面牆，馬上就覺得我有我的理想與目標，不是來這裡交朋友，而是在工作上能與人愉快的合作建立自己得專業品牌才是我要的，這時候心裡立刻就不猶豫，自己去買飯火速解決。</p>

<p>以後又有不知道自己在幹嘛的感覺時，就會提醒自己那三個目標，幫我做出較為正確的選擇。真的很實用。莫忘初衷。</p>

<h2>結尾：不只雪中送炭，更錦上添花</h2>

<p>還有很多的情境，但不算是問題，但依然可以應用課程的知識去做強化。比如對於客戶安全感的管理，之後定期主動的提供消息（明確計畫與專業態度），主動去管理他們的不安全感。並且之後比如產品如何上線等情境也都提供選項，一方面我們可以收斂想法，一方面可以滿足客戶的掌控慾。</p>

<p>至於適度地提供壞消息並隨後擺平之，我把它定義為先說這個功能很難，要花多功，但我們可以做到，之後再完成，讓客戶提升安心感與風險免疫能力。</p>

<h2>關於日後練習</h2>

<ul>
<li>同理心的練習：找到關注利益與主要憂慮，才能找對策（參考一般性通則與職場人際對策速查表）</li>
<li>緩衝工作的判斷（比如客戶說不出明確時程，判定沒什麼成案機會是緩衝工作XD）</li>
<li>練習看懂局：找出關鍵人物，模擬他要什麼（同理心練習），加入時間因子（上過專案管理啟蒙後覺得時間很重要，而且常常是最重要的），最後理出頭緒。</li>
<li>人際關係計劃表：多跟有關的客戶窗口多聊天，在合作愉快得前提下，聊是否結婚，有沒有小孩，有沒有要出去旅行，有什麼興趣等等，只要記得客戶就會keep in mind。</li>
</ul>


<p>最後謝謝姚老師Bryan把這麼抽象的知識概念系統化的傳授給我們！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『大人學英文』對我未來日常生活的影響]]></title>
    <link href="http://sah.tw/blog/2017/09/03/learn-speak-english/"/>
    <updated>2017-09-03T23:34:06+08:00</updated>
    <id>http://sah.tw/blog/2017/09/03/learn-speak-english</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-09-03-learn-speak-english.jpg" alt="2017-09-03-learn-speak-english" /></p>

<h3>缺乏做法讓我知道如何改變</h3>

<p>大家學了這麼久的英文，一定有個願望是可以說英文。第一份工作時我擅長看國外的技術文章，簡單英文書信往來也沒有問題，但我就是無法用嘴巴說。問題在於如果我們今天認識了火星人，我們想學學看怎麼說，最有效的方式應該就是去偷聽他們對話，並且去模仿他們如何說，但我們通常不那麼做。</p>

<p>要說這堂課對我的影響，很簡單。如果我現在要說英文，流程不再是想法->中文->翻譯->英文。慢慢的我有感覺到中間的過程不見了，變成是想法->英文。</p>

<p>我其實不把這門課定調為『英文課』，而是定義為如何改變自我日常行為，進而達成有效提升英說能力的日常習慣改造課程。</p>

<p>我認為學英文需要時間，也需要方法。但大部分的方法無法讓時間在學習說英文上成為朋友，這門課珍貴的地方在於有能力讓時間變成你學習英文的盟友，but，同時也需要耐心與毅力。</p>

<p>這就我最愛的部分，因為我很清楚知道，能夠與人拉大差距能讓人稱羨的事情，一定需要時間耐心和毅力。所以我知道我走在對的路上。</p>

<h3>關於日後練習</h3>

<ul>
<li>每日聽Podcast一小時，當背景音聽，有辦法分神時注意聽內容。並挑五分鐘跟著說。</li>
<li>每日根據老師最常用100字去造句並說出來，並想像情境，讓自己講的有感覺。</li>
<li>看Suits，學Mike講話，每天就一句，錄下來並與影集做比較，做到越來越像。自己給自己回饋。</li>
</ul>


<p>最後謝謝Joy老師囉，也就是上面照片集美麗與智慧於一身的女神！
英文說得練習做到現在也邁入第三個月了，就如健身一樣，這需要時間，但方法對了堅持下去成果就很驚人, we will see.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎麼用簡報有效傳達訊息與說服對方]]></title>
    <link href="http://sah.tw/blog/2017/08/12/make-a-good-presentation/"/>
    <updated>2017-08-12T23:34:06+08:00</updated>
    <id>http://sah.tw/blog/2017/08/12/make-a-good-presentation</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-08-12-make-a-good-presentation.jpg" alt="2017-08-12-make-a-good-presentation" /></p>

<blockquote><p>這個月初因為朋友建議去上了<a href="https://www.facebook.com/ZHSun6">孫治華</a>老師的<code>【SmartM 菁英商學院】成功提案！打造商務簡報說服力</code>課程。上完課後火速改了簡報內容並去跟客戶簡報，真的發現客戶聽得異常專心，對於我要表達的重點也能夠真的抓住，實在是又驚又喜。在這裡把一些實戰後的心得記錄一下，以供自己與別人參考。</p></blockquote>

<p>做簡報的第一步想的不是自己的產品有什麼優點，或自己產品的任何事情，而是想想看別人可能會問我們什麼問題？針對這些問題我們的產品有那些優點可以來解決對方的疑惑。</p>

<h3>開場吸引力</h3>

<p>第一階段重點在於要讓對方有興趣。而要讓對方有興趣你的簡報就要有吸引力，吸引力來自於讓對方感覺這個簡報真的跟我有關係。立即針對對方的痛點提出解法是一個好的開場。</p>

<p>想像兩個圓，分別是對方的問題，還有我們產品的優勢，中間交集的地方就是我們要讓對方一開始就清楚知道的。所以做簡報前先開一個會前會，業務與技術一起加入，主題就是猜想對方現階段遇到的前三大問題。並且針對這三個問題提出我們產品的對應解法。業務負責依照在客戶端搜集的情報來提供問題，技術負責共同提出可行的解法。</p>

<p>而在開場部分你所提出的解法，不要太囉唆，這裡解法著重在結果，也就是效益的部分WHAT。至於技術的細節比如你如何做到的HOW，在這裡先不要提。比如客戶擔心效能問題，就先展現出強大的壓測數據，至於你如何做到，開場這邊先不用提。</p>

<p>其實只要你有辦法一開始就說出對方心中大部分的疑慮，你就可以初步贏得對方的信任感，因為對方會覺得你懂我。</p>

<h3>中場專業力</h3>

<p>第一階段說了一大堆效益，開了一堆支票，那這時候一般人都會想<strong>真的嗎？</strong></p>

<p>所以在這個階段你要證明你不是在唬爛。有可能你已經有實際上線成功案例可以拿來講，可能你有數據可以顯示，重點在於這個階段因為前面你說了太多的好，人性會不自覺懷疑，所以這裡需要透過幾頁來證明你有經驗有能力試做得到的。</p>

<p>再來就可以談談技術面的細節，比如你如何做到你前述的那些優點，這裡你可以依照自己的狀況，用自己的方式來讓對方瞭解，如果你有讓對方上了一課的感覺那更好，更能增加聽者對你的信任。這裡的難處會在於一般技術細節表達上會過於死板生硬，所以需要小組腦力激盪用流程圖、對比圖或是表格等讓聽者容易了解。</p>

<h3>終場執行力</h3>

<p>這時候依照對方的狀況加上時間以及做法，給對方一個藍圖去知道接下來要怎麼做。這裡如果是系統可以分批分階段汰換，如果是元件開發則可以列出從需求分析到驗收的時間表。</p>

<p>這裡重點在於讓對方理解你有執行這方面的經驗，可以依照他們的需求帶領他們。</p>

<h3>換個順序說說服力道就不一樣</h3>

<p>曾經聽過一個笑話</p>

<blockquote><p>女大學生晚上會去酒店陪酒 →社會觀感不佳。酒店小姐白天堅持去大學聽課 →充滿正面能量好勵志！</p></blockquote>

<p>當然上面這個笑話聽起來不一樣單純是因為語意關係，而簡報順序換個順序說服力道會不一樣是因為我們順著人被說服時的邏輯去編排簡報順序。嘗試依照吸引、專業、執行三個階段去簡報內容，更能夠抓到重點說服客戶達成簡報目標。而且依照問題導向去製作簡報，時間真的也短很多，也證明好的簡報不要花太多時間做，通常會花太多時間都是在空想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Production系統的穩定機制]]></title>
    <link href="http://sah.tw/blog/2017/08/05/high-availability-production-environment-issue/"/>
    <updated>2017-08-05T16:20:09+08:00</updated>
    <id>http://sah.tw/blog/2017/08/05/high-availability-production-environment-issue</id>
    <content type="html"><![CDATA[<p>​ <img src="http://mrshih.github.io/images/2017-08-05-high-availability-production-environment-issue.jpg" alt="2017-08-05-high-availability-production-environment-issu" /></p>

<p>要上線一個系統，或更新一個系統的版本，首先最重要的就是系統穩定度。有些系統比如在銀行，上線後出了問題都是非常緊急的，一但系統上線開放給別人來使用，背後需要考慮的完善，才不會上線之後一直在救火救不完。</p>

<p>底下從底層的Exception的機制、Log的紀錄方式、整體功能的完整性驗證、系統如何維持總是不死的狀態，到最後如果還是發生持續性錯誤如何處理，依序來談談資訊系統上到Production前，需要先考慮到的議題。</p>

<h3>底層的Exception機制</h3>

<p>最重要就是有錯誤產生就一定要在程式碼有catch到，並請定義好這個狀況搭配的錯誤代碼為何。有時會看到工程師在catch裡面不做任何事情，這是不被允許的，一旦出了問題大家都一頭霧水無法在第一時間了解狀況，影響到處理問題的黃金時間。而設計系統架構時就把錯誤回傳方式定義好，比如以下例子，後端程式只要判斷result為0，就可以知道有錯誤產生，並且讀取errorCode做相對應的處理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "result": 0,
</span><span class='line'>    "errorCode": 13057
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Log的紀錄方式</h3>

<p>Log最終是要拿來分析的，不管是程式分析還是人眼分析，都需要一個清楚固定的格式，尤其是第一時間往往要靠人眼去分析，這時候Log寫的工整與完整，絕對有助於除錯。一個好的格式必定要包含時間When，是誰Who，發生了什麼事What，錯誤代碼或錯誤訊息。</p>

<h3>整體功能的完整性驗證與壓力測試</h3>

<p>上線或更版之前，必定要做兩件事，功能性驗證與壓力測試。功能性驗證我常用的做法是寫自動測試，把所有預期狀況都寫成一個case，上線前的版本都要掃過並驗證功能正常。再來壓力測試就是測試針對大量併發連線，大量持續呼叫，服務是不是依然回應正常。</p>

<h3>維持總是不死的狀態</h3>

<p>服務如果持續回應，但是回應一樣的錯誤怎麼辦？這時候系統要能判讀錯誤並自我修復，比如re-try機制，如果socket連線斷掉等等，系統要能夠自我偵測並且主動重新連線。另一種狀況則是如果系統遇到fatal error，要使用<a href="http://linux.vbird.org/linux_basic/0560daemons.php">守護進程</a>，讓作業系統保護這個程式，一但偵測到結束訊號，要主動重啟服務。</p>

<h3>如果還是發生持續性錯誤如何處理</h3>

<p>第一時間要通知維運人員，常見做法是發送Email，並包含足夠的錯誤訊息資訊，如果環境開放一點的可以串接Slack API。因為這個時候已經發生系統沒有考慮到的狀況，才會導致服務停擺。第一時間常是手動重啟系統，再來看Log找錯誤，加入開發排程，緊急的話開一個<a href="https://ihower.tw/blog/archives/5140">Hotfix branch</a>出來，修正後把錯誤的狀況寫入文件中把狀況、原因、如何處理寫清楚，避免再次發生。</p>

<h3>不斷的進化的過程</h3>

<p>如何開發一套系統能在各種狀況下穩定的提供服務，是需要開發團隊透過敏捷開發方式加上完善的文檔與強烈的責任感共同來達成，不是一個容易的目標但一但達成是非常有價值的經驗也能提供很高的自我成就感。以上僅是列出部分議題，還有更多HA機制比如多台互為備援等，等待日後去實踐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多人異步開發產品的基礎設施]]></title>
    <link href="http://sah.tw/blog/2017/07/22/tec-infrastructure/"/>
    <updated>2017-07-22T14:20:09+08:00</updated>
    <id>http://sah.tw/blog/2017/07/22/tec-infrastructure</id>
    <content type="html"><![CDATA[<p>​ <img src="http://mrshih.github.io/images/2017-07-22-tec-infrastructure.jpg" alt="2017-07-22-tec-infrastructure" /></p>

<p>長期開發並維護一個產品跟短期衝刺生產出一個專案，最大的差別在於開發流程。負責小元件或小專案在開發上是同步進行的，而產品或大系統在開發上是異步進行的。開發元件可以用土法一路衝到最後，但開發系統沒有完善的基礎設施，案子很快就會出現許多問題導致開發窒礙難行。</p>

<p>如果以往是開發小系統，但突然有一天有機會接觸大系統的開發或規劃，沒有這些概念先Keep in mind，開發路上就會很辛苦了。</p>

<h3>同步進行</h3>

<p>小專案需求訪談後產生工作說明書然後簽字畫押好，只要規格寫的好範圍是可以被確定的，也不可以隨意亂改<del>，改了可以再收錢</del>。所以開發者一開始就能清楚界定專案的範圍，大部分未知的風險比如技術瓶頸可以被事先預知，開發時間可以被事先規劃。所以實務上從撰寫規格書界定專案範圍，再來實際開發最後到測試與驗收，流程上是以同步(sync)的方式進行。</p>

<h3>異步進行</h3>

<p>而大部分產品會給多個客戶使用那就會有多重意見和偏好，再來因為想做的功能多，甚至很多功能是要做但現在還沒辦法做，一開始也就是先畫出WBS圖來大略上界定範圍，很難一開始就寫好完整版規格書，界定所有API。而是隨著時間發展，常常是先寫好幾個客戶緊急需要的模組，然後就出貨給客戶，之後陸續再Release新版補給客戶其他沒有那麼緊急或重要的功能。而一但把時間因素拉長並考慮進去，開發上很多問題就會浮現了。</p>

<h4>緊急事件</h4>

<p>有緊急狀況發生比如出貨的產品臨時被要求在上線前要提供弱掃報告與修正，那這時後原先預定的下一個版號要新增的功能就要被置換成修正弱掃缺點。原本要被Merge回來的Feature支線就要暫緩，並且火速開一個Feature來修改弱點並發布成一個版本。</p>

<h4>Feature要不要Release的抉擇</h4>

<p>如果有很多新功能都接近完成，這時候要Release那些到下一版？通常第一個要考慮的是客戶的安心感。比如新功能要犧牲效能來換取穩定度，這時候要犧牲多少效能？這數字是客戶可以接受的嗎？客戶搞不好寧願犧牲穩定度來換取效能？如果客戶有多個有的可以有的不行呢？</p>

<p>上述沒有考慮到就貿然Release出去，如果驚嚇到客戶，讓客戶對我們信心感和安全感下降這都是很嚴重的損失。</p>

<h4>本版間的關係管理</h4>

<p>隨著時間迭代，A客戶是0.8版，B客戶是0.9版，這時候怎麼從0.8升級到0.9？兩個版本之間又有什麼差別？如果是好幾10個版本分散在各地有辦法處理嗎？如果沒有搭配文件、程式碼版本控管、環境印象檔化，不用多久整個案子就會無法維護。</p>

<p>文件記錄各版本的Release note，並且要有規範，標明新功能和已知問題等。版本控管Git要有Git Flow如Release branch在程式標明版本號，和Tag標註方便切換不同版本。運用Docker把運行環境標準化<a href="https://www.thoughtworks.com/insights/blog/infrastructure-code-reason-smile">Infrastructure as Code</a>，除了確保開發時與上線的反應相同，也避免環境升版降版時遺漏了設定造成的錯誤。</p>

<h4>眾多協同開發會遇到的協作工具</h4>

<p>Product version control document、Git、Auto test、CI Server、Project Management Know How(WBS etc…)、Document Guideline、Issue tracking等，以上這些就像是現代產品開發所必備的基礎設施，少了這些要開發大型系統或隨著時間迭代成長的產品是不可能的事情，沒有這些整個技術Team無法持續成長，也會欠下一堆技術債，累積到最後整個產品開發寸步難行，而對風險的忍受度也會異常的低，比如一個關鍵開發人員走了整個產品開發就無以為繼了。</p>

<p>從開發元件與小APP到現在開發產品，遇到的問題很多已經不是單一技術面，更多是如何管理這堆技術生老病死的問題，僅記錄一些最近遇到的實際問題與想法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Letsencrypt在nginx與centos環境下實作tips]]></title>
    <link href="http://sah.tw/blog/2017/04/12/letsencrypt-nginx-centos/"/>
    <updated>2017-04-12T14:20:09+08:00</updated>
    <id>http://sah.tw/blog/2017/04/12/letsencrypt-nginx-centos</id>
    <content type="html"><![CDATA[<p>基本上我認為現在<a href="https://lynn1205.wordpress.com/2017/01/18/%E4%BB%80%E9%BA%BC%E6%98%AF%E4%BC%BA%E6%9C%8D%E5%99%A8%E6%86%91%E8%AD%89ssl/">HTTPS</a>的功用只是用來加密連線，在CA亂發或誤發的時代，不能指望CA這樣的盈利民間機構能盡責的做到驗證申請者的角色。
但然而能做到加密Server與Clint之間的通訊內容其實也就已經足夠了。</p>

<p>與其繳錢給盈利CA，現在你有更好的選擇-<a href="https://letsencrypt.org">letsencrypt</a>，免費開源自動化更新的CA。</p>

<p>網路上的教學文章不少，而我這邊整理幾個好用的tip，主旨在於自動化與降低維運的難度。</p>

<h2>Step0. CentOS+Nginx</h2>

<p>因為自己的Server是用這樣的環境，加上這個環境也非常普遍可靠穩定，所以本文章就以這個環境當做基底。</p>

<h2>Step1. Nginx強制指定/.well-known/acme-challenge/檔案路徑</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/etc/nginx/nginx.conf
</span><span class='line'>
</span><span class='line'>server {
</span><span class='line'>  listen       80;
</span><span class='line'>  
</span><span class='line'>  location ^~ /.well-known/acme-challenge/ {
</span><span class='line'>      default_type    "text/plain";
</span><span class='line'>      root    /var/www/letsencrypt;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你必須向letsencrypt證明DNS指向的這台server是你host的，等等letsencrypt會去你domain下的<code>/.well-known/acme-challenge/</code>path查找文件，如果找得到就能證明是你host，也才能簽發證書給你。</p>

<p>而這裡統一指向<code>/var/www/letsencrypt</code>是因為有可能你現在用單純的html環境，有可能之後換成<code>proxy_pass</code>反向代理到node.js等，這都會使得<code>/.well-known/acme-challenge/</code>這個url路徑指向的檔案在你host的server上產生變動，這種業務上變動跟HTTPS是無關且可以切開來降低兩邊的耦合度，而隨著日後的domain變多，統一指定路徑這樣的做法也能夠降低後續維運的難度。</p>

<h2>Step2. 申請憑證</h2>

<p>去下載官方的驗證tool <a href="https://certbot.eff.org">certbot</a>並安裝，下面例子自行把abc代換成你的domain</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>certbot certonly --webroot -w /var/www/letsencrypt/ -d abc.com.tw -d www.abc.com.tw</span></code></pre></td></tr></table></div></figure>


<p>成功的話會出現包含Congratulations!一大段話，憑證會被存在<code>/etc/letsencrypt/live/abc下</code>。</p>

<h2>Step3. 安裝憑證到Nginx</h2>

<p>/etc/nginx/conf.d/abc.conf</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>listen       443 ssl;
</span><span class='line'>server_name  www.abc.com.tw;
</span><span class='line'>
</span><span class='line'>ssl_certificate      /etc/letsencrypt/live/abc/fullchain.pem;
</span><span class='line'>ssl_certificate_key  /etc/letsencrypt/live/abc/privkey.pem;</span></code></pre></td></tr></table></div></figure>


<h2>Step4. 強制導流HTTP連線到HTTPS</h2>

<p>/etc/nginx/nginx.conf</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>server {
</span><span class='line'>  listen 80;
</span><span class='line'>  server_name _;
</span><span class='line'>  return 301 https://$host$request_uri;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Step5. 把更新任務加入crontab自動化更新憑證</h2>

<p>以下為更新腳本，我是命名為renewCerts.sh，並存放在/etc/letsencrypt/下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/sh
</span><span class='line'># This script renews all the Let's Encrypt certificates with a validity &lt; 30 days
</span><span class='line'>
</span><span class='line'>if ! /usr/bin/certbot renew &gt; /var/log/letsencrypt/renew.log 2&gt;&1 ; then
</span><span class='line'>    echo Automated renewal failed:
</span><span class='line'>    cat /var/log/letsencrypt/renew.log
</span><span class='line'>    exit 1
</span><span class='line'>fi
</span><span class='line'>nginx -t && nginx -s reload</span></code></pre></td></tr></table></div></figure>


<h2>Step6. 把sh加入crobtab</h2>

<p>打開crontab設定檔</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo crontab -e</span></code></pre></td></tr></table></div></figure>


<p>加入sh設定每日自動執行然後儲存</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@daily sh /etc/letsencrypt/renewCerts.sh</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker系列3 - Container間的溝通]]></title>
    <link href="http://sah.tw/blog/2017/02/14/docker-containers-communicate/"/>
    <updated>2017-02-14T15:53:23+08:00</updated>
    <id>http://sah.tw/blog/2017/02/14/docker-containers-communicate</id>
    <content type="html"><![CDATA[<p>這系列文章從建立Container，建立Volume，至此我們已經可以去建立提供不同的服務Micro Service了，而剩下的議題變是如何讓Micro Service之間彼此溝通。</p>

<h2>不同Host間的Containers彼此溝通</h2>

<p>如果Micro Service在不同的實體機器中，則可以透過<code>run</code>指令裡的<code>-p</code>來把Container與Host的特定給對應起來。</p>

<p>比如以下指令就是啟動一個Web Container並且把Host的Port 3000與Container的Port 80給串連起來</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -p 3000:80 web</span></code></pre></td></tr></table></div></figure>


<p>那接下來就可以在Host用127.0.0.1:3000來訪問Web Container的Port 80。</p>

<h2>同Host間的Containers彼此溝通</h2>

<p>而當Containers都在同一個Host，比如一個是Web一個是DB，Web要如何連上DB呢？其實每個Container在run的時候預設都是走bridge模式，這裡就是docker會創建一個veth interfaces，讓該host的Containers都跑在同一個network。</p>

<p>只要用<code>inspect</code>指令就可以查到該Container的詳細資訊，而裡面的Key<code>IPAddress</code>就會有IP資訊。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker inspect [Container-ID]</span></code></pre></td></tr></table></div></figure>


<p>在同個veth環境下，有了IP，Container之間就可以彼此溝通了。</p>

<h2>FYI</h2>

<p><a href="https://docs.docker.com/engine/reference/run/#/network-settings">https://docs.docker.com/engine/reference/run/#/network-settings</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker系列2 - 運用Volume分離資料]]></title>
    <link href="http://sah.tw/blog/2017/02/13/docker-volume/"/>
    <updated>2017-02-13T14:23:05+08:00</updated>
    <id>http://sah.tw/blog/2017/02/13/docker-volume</id>
    <content type="html"><![CDATA[<h2>為什麼要用volume？</h2>

<p>Docker的Container有個重要的原則是不儲存資料。為什麼呢？比如你做一個Web Service的Image，你把NPM,前端分流Nginx等軟體都安裝好了，這時候要把網頁的檔案放進去，一種做法是在<code>Dockerfile</code>裡面用<code>COPY</code>把網頁檔給複製進Image裡面，然後再Run起來。</p>

<p>可是這種把不斷變動的資料檔案存在Image裡的做法會帶來許多問題，我如果改一行Code我不就要重新Build或新Commit一個Image嗎？我如果有好多個網站要跑在不同的Container上，我不就要做好多個Image？如果是DB的Image，把DB File放在Image裡面，那不就隨著時間過去Image就要一直更新了?</p>

<p>所以在製作Image上，常見的best practice是把執行環境打包成Image，而時常會修改的檔案比如網頁檔案或資料庫檔案這些<code>資料</code>就另外掛載在Volume上，也就是Mount在Host機上的資料夾。這樣就可解決上面所提及的問題。</p>

<p>底下我們就以網頁服務常見的/var/www資料夾與資料庫常見的/var/lib/mysql為例，操作如何把這兩個存<code>資料</code>的地方給另外存在volume上。</p>

<h2>製作data volume container</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker create -v absolute/path/to/host/dir:/var/lib/mysql --name dbdata mysql   //產生一個container, 掛載host資料夾(absolute/path/to/host/dir)到container的/var/lib/mysql</span></code></pre></td></tr></table></div></figure>


<p>這裡的-v用法就是用來掛載volume的，去mount一個host資料夾為container的data volume。並且把這個container指名為dbdata，這種container又稱作為<code>data volume container</code>。</p>

<p>這種container特別在於本身只是用來記載那個host資料夾對應mount到container的那個資料夾，所以container本身是不用啟動(run)的。</p>

<p>PS. 如果Host的dir沒有指定，則docker會在系統的某個陰暗角落建立一個新的資料夾。可以用<code>docker inspect container-id</code>指令回傳結果裡key<code>Mounts</code>的Dictionary裡找到那個陰暗角落。</p>

<h2>使用data volume container</h2>

<p>有了data volume container後，只要以後在run container時透過<code>--volumes-from</code>參數，就可以直接把指定的<code>data volume container</code>的volume給掛載進來。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run --name=mysqldb -d -p 3306:3306 --volumes-from= dbdata mysql</span></code></pre></td></tr></table></div></figure>


<p>這時候新產生名為mysqldb的container，cd到<code>/var/lib/mysql</code>就會發現與host的<code>absolute/path/to/host/dir</code>資料夾是連動的，也就是mount再一起了。</p>

<p>舉個實用情境，假如資料庫版本要升級，只要在<code>Dockerfile</code>裡面升級資料庫版本，然後把新的container啟動時掛載dbdata，資料就還是一樣。而如果當初沒有把<code>資料</code>從Image分離出來，是要不原本DB的資料給匯出，再匯入新Image，非常麻煩，而不這麼做DB的紀錄就消失不見囉。</p>

<p>這裡的效果也就是<a href="https://docs.docker.com/engine/tutorials/dockervolumes/">官方介紹</a>的volume主要用途，把<code>資料</code>與container分開，達到data persistence的目的。</p>

<p><code>Data volumes are designed to persist data, independent of the container’s life cycle.</code></p>

<h2>同理可證的Web Service</h2>

<p>一但建構好基本環境，比如NPM, PM2, Nginx&hellip;etc，打包成一個Image後創建Container，以後Run這個Container只要搭配以下參數，就可以在本地修改，然後在container裡面實際測試了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-v absolute/path/to/host/web/dir/project:/var/www/project</span></code></pre></td></tr></table></div></figure>


<p>比如以下指令就是啟動一個已經安裝所需運行環境的image（npm-ready），然後指定Host資料夾（/Users/shih/Desktop/lab/PSControlCenter）掛載到Container的/var/www上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -i -t --name center -p 9453:3001 -v /Users/shih/Desktop/lab/PSControlCenter:/var/www npm-ready</span></code></pre></td></tr></table></div></figure>


<h2>FYI</h2>

<ul>
<li><a href="https://docs.docker.com/engine/tutorials/dockervolumes/">https://docs.docker.com/engine/tutorials/dockervolumes/</a></li>
<li><a href="https://jiajially.gitbooks.io/dockerguide/content/chapter_fastlearn/docker_run/data_manager.html">https://jiajially.gitbooks.io/dockerguide/content/chapter_fastlearn/docker_run/data_manager.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker系列1 - 從Image到Service]]></title>
    <link href="http://sah.tw/blog/2017/02/09/docker101/"/>
    <updated>2017-02-09T13:22:36+08:00</updated>
    <id>http://sah.tw/blog/2017/02/09/docker101</id>
    <content type="html"><![CDATA[<h2>本身工作偏開發，為何要了解Docker？</h2>

<p>最近Micro service火紅，大型服務被切成一個一個小模組，減少彼此耦合，個別跑在各自container上，方便重複部署，且彼此互相用Rest API或socket溝通。這樣帶來的好處在於可以在開發上減少後續迭代的困難，減少維運的難度，增加系統穩定性。</p>

<p>但要獲得這些好處，軟體在最初開始設計架構的階段就要拆分服務，一開始設計不好之後就算有docker工具那也只是把所有服務丟到同一個Container上，沒有辦法發揮docker切割服務的優勢。</p>

<p>所以想成為架構師，當然不能不了解這個工具。而從程式開發上來看，能夠把CI Keep in mind，有新Commit Push到develop branch，CI Server就自動執行下面步驟</p>

<ol>
<li>打包新的Image</li>
<li>產生Container</li>
<li>執行Service</li>
<li>Run Test Code&hellip;</li>
</ol>


<p>能夠協助開發者確保最終程式碼在Production環境是可以正常運行，有問題可以立即發現與處理。</p>

<p>Docker對比傳統VM優點在於所消耗資源很小，啟動速度很快，並且兼具傳統VM打包成Image擋可以Anywhere都快速建立起一樣的Service等優點。</p>

<p>這篇文章主要就以上面幾點依序從包含如何製作Image，產生Container，利用Container啟動我們要的Service，最後如何匯出部署到另一台機器等一系列記錄下來。</p>

<h2>Dockerfile與Base Image</h2>

<p>要導入的Service是由三個部分組成</p>

<ol>
<li>Node.js專案，用Express作為Route Framework，為業務邏輯層負責API JSON的輸出</li>
<li>Node.js專案，用Express作為Route Framework，使用Bootstrap來包含View的後台操作介面</li>
<li>MySQL Instance</li>
</ol>


<p>之前做法是把Node.js專案都放在同台Server，但因爲HA需要，所以也有一台Hot standby的實體機並排在HAProxy下。這裡帶來第一個問題是當要重新build環境時靠Install Guide手動安裝很不方便，解決方法便是用<code>Dockerfile</code>，把Install Guide所需的環境與步驟打包成一個Image。</p>

<p>1&amp;2專案相同部分是<code>Node.js專案，用Express作為Route Framework</code>，所以可以Build一個Base Image來當基底環境，之後只要分別把<code>/var/www</code>置換成對應的專案檔即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM centos:7 // 指定CentOS
</span><span class='line'>MAINTAINER daan.shih@gmail.com
</span><span class='line'>RUN yum install -y epel-release // -y避免互動輸入
</span><span class='line'>RUN yum install -y nodejs
</span><span class='line'>RUN yum install -y npm
</span><span class='line'>RUN npm install pm2 -g
</span><span class='line'>RUN mkdir /var/www/
</span><span class='line'>WORKDIR /var/www/</span></code></pre></td></tr></table></div></figure>


<p>有了Dockerfile後就可以Build Image了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker build -f /path/to/dockerfile ./</span></code></pre></td></tr></table></div></figure>


<p>之後會得到一個Image ID，因為是只安裝npm基底就取名為npm-ready</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker tag [Image ID] npm-ready</span></code></pre></td></tr></table></div></figure>


<p>現在打<code>docker images</code>應該可以看到類似<code>npm-ready               latest              43c671f848fd        22 hours ago        405.6 MB</code>的資訊</p>

<h2>以Base Image為底，加入express專案檔</h2>

<p>這時候我們已經有一個Image檔，包含npm與必須的tools，只缺express專案檔。所以接下來就以<code>FROM</code>指令，指定以<code>npm-ready:latest</code>為底，用<code>COPY</code>指令把我們需要的專案檔複製到Image中。</p>

<p>這裡要注意第三行的<code>PSControlCenter/</code>這個目錄必須與Dockerfile同一個目錄（<code>docker build</code>後面會加上的path我們是打./），不然會出現找不到此目錄。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM npm-ready:latest
</span><span class='line'>MAINTAINER daan.shih@gmail.com
</span><span class='line'>COPY ControlCenter/ /var/www/</span></code></pre></td></tr></table></div></figure>


<p>得到新Image ID後幫它補上名字方便識別</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker tag [Image ID] control-center</span></code></pre></td></tr></table></div></figure>


<h3>Image to Container</h3>

<p>至此我們已經有一個包含全部所需要檔案的Image檔<code>control-center</code>了。現在只需要利用Image去產生一個Container，並且執行這個Container就行了。</p>

<p>本來產生<code>create</code>與執行<code>start</code>是兩個指令，這裡可以用<code>run</code>來代表連續執行上面兩個指令。類似git裡面<code>pull</code>是連續執行<code>fetch</code>和<code>merge</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -t -i -p 9453:3000 [Image ID] /bin/bash</span></code></pre></td></tr></table></div></figure>


<p>這裡要注意的是<code>-p</code>，每個運行中的container的網路環境與host是完全分離的，所以我們要從外部去訪問container，就要用這個指令來指定port的相依關係。</p>

<p>這個例子裡我們在host輸入127.0.0.1:9453就會訪問到container的3000 port。</p>

<p>建立完container後，這時可以透過下面指令拿到Container ID</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker ps -a // -a會列出所有container(包含停止)</span></code></pre></td></tr></table></div></figure>


<p>運行container後，想再得到運行狀態中的container的bash shell可執行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker exec -it [container-id] bash</span></code></pre></td></tr></table></div></figure>


<p>exec指令就是對該運行中的container下達指令。</p>

<h2>Run Service</h2>

<p>到這裡我們已經利用Image去產生Container，並起啟動了Container，指定了Port的映射關係，最後取得該Container的Shell。這時環境已經建立起來，我們就可利用PM2把service給run起來：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pm2 start ./bin/www --watch --name "www"</span></code></pre></td></tr></table></div></figure>


<p>然後在Host瀏覽器訪問127.0.0.9453，就可以看到服務啟動了。</p>

<h2>部署在另一台機器上</h2>

<p>把control-center這個Image用<code>save</code>指令匯出成.tar檔</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker save control-center &gt; ./control-center.tar</span></code></pre></td></tr></table></div></figure>


<p>接著在另一台的Dokcer instance上用<code>load</code>指令，指定tar檔路徑匯入成image</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker load &lt; /path/to/control-center.tar</span></code></pre></td></tr></table></div></figure>


<p>再來用<code>docker images</code>來確認是否有成功匯入Image<code>control-center</code>。</p>

<p>之後我們便可以把該Image<code>control-center</code>打包匯出到其他機器，短短的兩行幾秒內就把服務給建立起來，非常輕鬆寫意的部屬方式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -t -i -p 9453:3000 [Image ID] /bin/bash
</span><span class='line'>pm2 start ./bin/www --watch --name "www"</span></code></pre></td></tr></table></div></figure>


<h2>Next</h2>

<p>下次介紹另一個Docker的重要概念：Volume。Container與Image有個很重要原則是裡面不要存Data，也就是不要把MySQL的資料給存在Image裡，所以在資料庫相關的Container裡有關Data的部分會採用另外掛載的方式。</p>

<h3>參考FYI</h3>

<ul>
<li><a href="http://dockone.io/article/783">http://dockone.io/article/783</a></li>
<li><a href="http://dockone.io/article/128">http://dockone.io/article/128</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[期末報告如何才能拿最高分？讓教授幫你做報告]]></title>
    <link href="http://sah.tw/blog/2017/02/01/independent-study-get-good-grades/"/>
    <updated>2017-02-01T00:50:13+08:00</updated>
    <id>http://sah.tw/blog/2017/02/01/independent-study-get-good-grades</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-02-01-independent-study-get-good-grades.jpg" alt="image" /></p>

<p>大家都有這樣的經驗：辛辛苦苦絞盡腦汁，經歷無數夜晚暴肝打word，期末滿懷信心交出報告後，換來的是又一次的失望。</p>

<h2>不斷更新</h2>

<p>如果說一般考試把時間與心力砸下去結果就會好，皇天不負苦心人，那期末報告真的是一件令人頭大的事，時間心力砸下去只怕教授也不領情。那有沒有什麼方法保證最高分？有！很簡單，就是你不能只是把報告做完，你要做到一半就把報告拿給教授看，甚至要拿最高分你有必要寫個一兩頁就傳給教授看。</p>

<p>一開始比如說：「我想要從這家公司他們幾個創辦人的背景開始介紹，你覺得好不好？」，教授可能會說：「我覺得不好，因為xxx是個無趣的人，你不需要介紹他&hellip;.」，這時候你就改麻，然後再問他：「這樣好不好，那你覺得我哪裡可以再加強？」，教授如果說：「那我覺得你可以再focus在這上面&hellip;」，那就再回去加加加，增加篇幅之後再問&hellip;這樣一路反覆執行，到學期末，保證你絕對最高分！但是為什麼呢？</p>

<h2>不是教你諂媚</h2>

<p>注意！答案不是&#8221;最常跟教授接觸&#8221;，那比較像是諂媚，這裡絕對不是教你諂媚。這背後有一個原因為什麼會最高分，因為你這個報告等於是老師幫你做的阿，如果你真的定期跟老師update一些東西，這東西根本就是老師幫你做的阿。那讓老師幫你做這件事情是什麼意思？</p>

<p>剛舉的例子，老師就是那個消費者，你一直去推這個產品、一直去測試消費者，一直修改，直到消費者買單為止麻！你可以一直測試一直測試、一直修改一直修改，不要悶著頭一直寫、不要怕被指出錯誤，這個過程，不管是做報告也好，或是做事情也好，是你最該擁有得一種態度。</p>

<p>不要把所有的事情都堵住到一擲上面，如果你在最後一個禮拜要發表的時候才讓教授知道你的全部想法，看到你的全部東西，你仔細想想，這不是一件在賭樂透的事情嗎？你之前完全都沒有回應耶！也都完全不知道教授對你報告的想法，猜牌算牌都不想做，就在最後一刻突然翻出你的底牌，你根本就是在賭樂透。</p>

<p>跟老師溝通，肯定你的作品，這中間要懂得清楚跟老師表達你做了什麼、清楚理解並記下老師希望你做些什麼、配合老師時間、反覆溝通記錄、鍥而不捨的修改、抓到老師口味、持續的update&hellip;這些都很難耶，這也都是你真正的價值。這些東西比你待在家裡、不用接觸老師、照著自己意思做，那樣最簡單！</p>

<p>不只&#8221;完成報告&#8221;，運用這個來回溝通的方法&#8221;完成老師滿意的報告&#8221;。而出了社會以後，面對上頭交辦下來的事情，別人埋頭苦幹而你會善加利用這點完成事情，成果老闆上司都滿意，你跟別人自然就立分高下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Search應用]]></title>
    <link href="http://sah.tw/blog/2017/01/25/search/"/>
    <updated>2017-01-25T18:18:02+08:00</updated>
    <id>http://sah.tw/blog/2017/01/25/search</id>
    <content type="html"><![CDATA[<p>iOS 8之後搭配<code>UISearchController</code>，只要把屬性<code>searchResultsUpdater</code>指定物件在<code>updateSearchResultsForSearchController</code>這個方法中實作filtering and updating就可以了。非常方便。</p>

<h3>Fetch data</h3>

<p>從Server抓取資料，這裡我們用<code>originalDatas</code>這個instace variable存JSON陣列資料。注意Retain Cycle即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Feth data from server and reload.
</span><span class='line'>__weak MemberListTableViewController *weakSelf = self;
</span><span class='line'>[TNUserManager logInAccountInBackgroundWithAccount:@"andy" password:@"12344321" success:^{
</span><span class='line'>    [TNUserManager getContactbookWithSuccess:^(NSDictionary *responseObject) {
</span><span class='line'>        weakSelf.originalDatas = (NSArray*)responseObject;
</span><span class='line'>        [weakSelf.tableView reloadData];
</span><span class='line'>    } failure:^(ResultInfo *resultInfo) {
</span><span class='line'>        NSLog(@"get data fail");
</span><span class='line'>    }];
</span><span class='line'>} failure:^(ResultInfo *resultInfo) {
</span><span class='line'>    NSLog(@"login fail");
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h3>Filtering and Updating</h3>

<p>利用<code>NSPredicate</code>制定陣列搜尋規則，這裡是指定陣列內有包涵<code>searchString</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** Filtering **/
</span><span class='line'>// 搜尋規則
</span><span class='line'>NSPredicate *preicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searchString];
</span><span class='line'>
</span><span class='line'>// 搜尋
</span><span class='line'>NSMutableArray *reslut = [[NSMutableArray alloc]init];
</span><span class='line'>// loop each people
</span><span class='line'>for (NSDictionary *each in self.originalDatas) {
</span><span class='line'>    Boolean isMatch = false;
</span><span class='line'>    
</span><span class='line'>    // list all value of people
</span><span class='line'>    NSMutableArray *values = [NSMutableArray arrayWithArray:[each allValues]];
</span><span class='line'>    
</span><span class='line'>    // 把property的屬性為array的提取出來
</span><span class='line'>    for (id proerty in values) {
</span><span class='line'>        if ([proerty isKindOfClass:[NSArray class]]) {
</span><span class='line'>            if ([proerty filteredArrayUsingPredicate:preicate].count &gt; 0) {
</span><span class='line'>                // show
</span><span class='line'>                isMatch = true;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // 找剩下property的屬性為string的
</span><span class='line'>    if (isMatch == false) {
</span><span class='line'>        if ([values filteredArrayUsingPredicate:preicate].count &gt; 0) {
</span><span class='line'>            // show
</span><span class='line'>            isMatch = true;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    if (isMatch) {
</span><span class='line'>        [reslut addObject:each];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/** Updateing **/
</span><span class='line'>self.showDatas = [reslut mutableCopy];
</span><span class='line'>[self.tableView reloadData];</span></code></pre></td></tr></table></div></figure>


<h3>後續優化idea</h3>

<p>這個APP是做公司內部通訊錄的，而如果陣列裡面包涵員工ID，或到職日期等數字資料，就可以在<code>NSPredicate</code>字串比對完之後，搭配<a href="http://sah.tw/blog/2016/11/09/objc-quick-sort/">Sorting</a>來對數字做排序。</p>

<p>潮一點的搞個數據應用，可以把搜尋歷史用SQLite記錄下來，把<code>搜尋後而且點擊</code>這個元素加入到Sorting的條件中。這樣一來使用者越長搜尋的排序就會越前面囉。</p>

<p>最後也可以做成<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/index.html#//apple_ref/doc/uid/TP40016308">讓iOS系統搜尋Bar也可以找到APP內的資訊</a>，不過這樣就要把通訊錄存在本地端DB，而不能只是In-Memory JSON處理了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[為何愛成吉思汗健身房]]></title>
    <link href="http://sah.tw/blog/2017/01/17/why-love-mma-gym/"/>
    <updated>2017-01-17T23:21:00+08:00</updated>
    <id>http://sah.tw/blog/2017/01/17/why-love-mma-gym</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-01-17-why-love-mma-gym.jpg" alt="image" /></p>

<p>成吉思汗的館長說他開館就是相信台灣應該擁有更好健身房，所以要持續的提供台灣一個高水準的健身聖地，提升台灣人健身運動的專業風氣。討厭看到市場上充斥的都是直銷與只想賺錢的商業健身房與似是而非的健身觀念。</p>

<p>之前去過其他健身房，別的可能就是放很養眼的美女帥男圖，可能也會放勵志標語，比如今天得努力是為了什麼。但我特別喜歡成吉思汗該怎麼做就怎麼做的實幹精神，健身就是會苦，有苦才有收穫。每個人來這裡都是在跟自己比賽，而不是只是來打發時間。我們選擇在此時此刻來到這個健身房，是要互相見證彼此在痛苦中成長，我們能互相體會別人在力竭時努力的叫喊，猙獰的臉龐，而不會阿呦，這是在幹嘛。在這裡大家都在玩真的，真得都在健身，很有熱情想法的在看待這件事！沒有再跟你害羞，沒有再跟你玩半套。在這裡許多地方標語就是no pain no gain。</p>

<p>在這裡密集的上教練課，與教練聊天中知道這裡教練對於定期的考試大家都十分重視，不只是玩玩只求過就好，大家都追求好成績，互相幫忙當捕手教學對方不足之處，這裡教練是真心在追求身體上的進化與突破，跟著這樣的教練才能有學不完的東西，而我相信能夠不斷自我要求的環境這就是好的環境。</p>

<p>成吉思汗直接把台灣制霸印在門口，器材真多超多超齊全，妥善率也都很好，深蹲架排開就是六台，而全年保證不休息，想練隨時都可以來練，就連年過年除夕都不打烊，教練師資真的也專業又敬業。</p>

<h3>為何寫這篇？</h3>

<p>之所以打這一篇是因為跟一位熱愛運動但在考慮上健身房的朋友聊天，偶然聊到為什麼這麼多健身房我選擇了在三重沒有離我家很近的成吉思汗，我突然發現儘管我十分認同喜歡這裡，但我卻完全沒有辦法引起別人的共鳴。後來思考，這應該跟<a href="https://www.youtube.com/watch?v=qp0HIF3SfI4">Simon Sinek那個演講</a>想表達的是一樣。</p>

<p>我都是從WHAT跟HOW來開始跟別人講解，提陳吉思汗優點從有大量專業的器材，很壯的教練，口碑也都不錯的點切入，但我從WHAT跟HOW切入，結果就是聽的人不能感受成吉思汗特別得地方。我試著從WHY這個角度切入，也希望下次我再推坑其他的人的時候能更引起別人共鳴，推坑成功。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[超級智能時代-人工智慧的不可擋與半世紀影響]]></title>
    <link href="http://sah.tw/blog/2017/01/01/ai/"/>
    <updated>2017-01-01T18:56:12+08:00</updated>
    <id>http://sah.tw/blog/2017/01/01/ai</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2017-01-02-ai.markdown.JPG" alt="image" /></p>

<p>談一本重要的書，超級智能時代，這本書裡談的議題對每一位讀者都絕對切身相關。人類剛經過一波的資訊革命，最近幾年資訊技術的成熟發展，包含移動網路與終端設備如手機的成熟，帶來資訊大爆炸。資訊大爆炸後有了足夠的數據量，收集起來嘗試找出某些規則，並運用這些規則來使人類生活更方便，也賺取了大把財富。</p>

<p>但從工業時代以來的每一波革命都是先造福一小部分群眾，過了許多年後全人類才能享有革命帶來的好處。這一波大數據與人工智慧的革命帶來的影響與衝擊非常之廣，人工智慧就是想解決以往人類才能解決的問題，會取代許多既有的勞動力，再疊加上一波資訊革命帶來的影響，根據歷史可以想見需要長達半世紀來消化過剩勞動力帶來的負面衝擊。</p>

<h3>從因果法到逆推法</h3>

<p>以往人類學習的方式是習慣先假設某種道理，之後再去累積數據去證明出這種道理;我們習慣先假設因，才去驗證結果。上幾個世紀人類都習慣這套思考模式，稱之為工業時代思考模式。而當時間來到現在，容易尋找的真理幾乎都被發現完了，我們要面對的是不確定性越來越高的問題，往往我們連問題該怎麼定義都沒有頭緒，所以藉由累積數據來說故事，從資料裡發現道理，便是為了回答現代越發複雜，且不確定性極高的智慧型問題的新思考模式。</p>

<h3>現代人工智慧</h3>

<p>其實大數據不是用來解決人工智慧的唯一方法。最早其實科學家是想模仿人類思考模式來製造人工智慧，但發現難以解決不確性高的問題。而隨著硬體如儲存技術得成熟，連結技術如移動網路的成熟，處理能力如資料中心的成熟，這三者技術同時準備好了，使得人類發現與其讓機器造著人類的想法走，不如餵給機器一堆資料，讓它從中自己試著回答問題，結果比之前的方法就結果來說都更好。</p>

<p>逆推方方法論變成資訊時代的方法論。</p>

<p>順著這個思考模式可以發現。掌握數據，更嚴格來講是大數據的人在未來才有可能回答現代社會中越發複雜的問題。大數據顧命思議就是大量的資料，而大量的數據加上多維度，便能從中去試著找出規律，總結成智慧。</p>

<p>所以從人工智慧方向往大數據的逆推方法論走後，『人類在人工智慧領域的成就，其實就是把各種智慧問題轉化為消除不確定性的問題，然後再找到能消除相應不確定性的資訊』。</p>

<p>下圍棋人類依靠經驗與眾多棋譜來學習如何取勝，而只要能把棋譜轉換成電腦可懂的規則，電腦就可以大量的去讀取歷史棋譜，能比任何人類一輩子讀的都還要多，最後轉換成數學模式，採用依照大量數據訓練加上統計知識所做出來的模型來回答問題。雖然棋的變化是無窮的，但機器總能找出勝率較高的步法。</p>

<p>AlphaGo在比賽中走出許多令人類專家跌破眼鏡的走法，但最後又能贏。這裡重點在於機器不必像人一樣思考，只要能夠解決人的問題就好了。在大數據中得出的智慧是數據加上統計的及果，是有可能出乎人意料外的，而且能做的更好。能不照常規行事其實就是超級智慧的表現。</p>

<p>而AlphaGo知道自己在下棋嗎？當然不知道。只不過把智慧問題轉換成數據問題。用統計方法搭配大數據解決智慧問題後機器從此無敵。</p>

<p>所以對於行事有特定SOP的技能，也就是非創造性工作的從業人員，大數據加上人工智慧是大有取代的勢頭。比如基金操盤手、醫師、會計師、司機、護士、農夫等。</p>

<h3>智能革命的影響</h3>

<p>在未來掌握大數據與運算能力的少數巨頭，目前來看如Google, FB, Apple, Amazon, Netflex和大陸的bat，這些公司如果和公權力結合，那就是全面監控了。CIA要來台灣抓人其實不用跟台灣警察打交道，透過你使用的手機說不定還比台灣警察更知道你的所在地。免費的服務往往是用自由換來的。你提供時間與數據，巨頭提供免費服務。在未來隱私的保護是重要議題。</p>

<p>技術帶來的各命常常是憂喜參半，喜的是改善人類生活，讓一些處在浪尖的人發揮更大的作用。但因為技術進步而被取代的人力，往往沒有辦法在學習新技術，所以只好『養著』，耗上兩代就解決問題了。</p>

<p>這次的超級智能最重要的影響是人類會發現自己能做得比機器好的事情不多了，很多人會在技術進步的途中發現自己被拋下了，新技術的發展不是每個人的機會都會變多，許多人反而是機會變少，如全自動化工廠之於生產線工人，計程車司機之於自動駕駛技術。這些大量勞動力該如何解決？書中其實沒有提出解決辦法，只能接受接在未來的幾10年會有越來越多事人類贏不了機器人。而之後所做的決定也都要依照這個大前提去行動。</p>

<h3>對於我個人</h3>

<p>看完這本書心中是興奮與恐懼，興奮的是對未來人類生活充滿正面積極的想像，恐懼的是害怕自己是對這未來至少50年影響人類最深遠的領域一無所知，最終被拋下，在自己的工作生涯毫不自豪。幸好我是相關科系相關產業，也還年輕肯學有興趣，往後推10年的努力都要與人工智能領域有關，投入在相關領域是我對自己未來的規劃。</p>

<p>以下是Youtube連結，台大教授林軒田老師的<a href="https://www.youtube.com/playlist?list=PLXVfgk9fNX2I7tB6oIINGBmW50rrmFTqf">機器學習基石</a> FYI。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AirPods個人使用評測：『能夠預知下一步的真智慧型耳機』]]></title>
    <link href="http://sah.tw/blog/2016/12/27/airpods/"/>
    <updated>2016-12-27T17:19:23+08:00</updated>
    <id>http://sah.tw/blog/2016/12/27/airpods</id>
    <content type="html"><![CDATA[<p><img src="http://mrshih.github.io/images/2016-12-27-airpods.jpg" alt="image" /></p>

<p>說到無線藍芽耳機我也是重度愛好者，早在前年就花了5位數大洋買了Sony的藍芽耳罩耳機<code>MDR-1RBTMK2</code>，那時候最麻煩的地方在於配對的不穩定和麻煩，都要先按鈕換醒耳機等待手機配對，有時找不到還要自己去連線。還有麥克風根本是雞肋，完全不能拿來講電話收音非常差，一有電話打來常常是手忙腳亂拔耳機選擇本機的Mic等等&hellip;好在上述的問題在AirPods都被完美的解決了。</p>

<h3>方便到一切成自然的拔掉單邊耳機</h3>

<p>常常戴耳機遇到一個情況是別人突然來找你講話，這時候拿掉一邊耳機另一邊都還播著歌，有時還是要手動把音樂關掉，而AirPods你只要拿掉其中一邊耳機，手機立即就會停止播放歌曲，真的是很實用的功能。</p>

<p>再來重點當你講完話，把耳機再放回耳朵時，音樂又會聰明的自動開始播放了！一切真的就是方便到成自然。想像你帶著耳機在電影，突然有人打擾！你帥氣的拿下單邊耳機電影立刻自動暫停，講完之後再戴回去電影立刻繼續播放！Magic~</p>

<p>你的下一個動作都預先被做好了，對我來說這就是智慧型產品，就叫方便！</p>

<h3>兩邊耳機都拿掉</h3>

<p>以前我用過的藍牙耳機當你兩邊都拿掉之後，你可能就是回到家不需要他們了，這時還要去手機裡面把輸出模式切換為原本的喇叭，多此一舉。而AirPods會自動偵測到你把兩邊耳機都拿掉了，iOS Device會自動把輸出切換回本機的模式。日常使用起來也是非常方便。</p>

<h3>麥克風</h3>

<p>真的很神奇，明明麥克風不在你嘴邊是在耳朵旁，可是你講出來的話還是很清楚的被收音了。使用AirPods後講了很多電話沒有人跟我反應不清楚。最後如果特別有問都會說我這邊收音很清楚很清晰。不管在捷運上或大馬路或安靜辦公室裡都OK的。</p>

<h3>連線穩定度</h3>

<p>搭配iOS Device很穩，就是穩。我想這是基本的啦。</p>

<h3>音質</h3>

<p>高音感受與有線一樣，低音感受比有線好蠻多的，至少我有感啦。音質很主觀，很在意的還是親耳聽聽吧。如果可以接受原廠有線的，那AirPods這個應該沒問題。</p>

<h3>電力與充電</h3>

<p>AirPods本身支援快充，你聽到剩4%快沒電了，放回AirPods case（就上面那個方形小盒子），約不到15分鐘就充超過一半了。充滿一次可以聽大概5個小時。實際使用上跟官方給的數據都很相近。自己用起來完全不擔心缺電。</p>

<h3>外觀</h3>

<p>這個就不用太在意吧，音樂是自己在聽的，而且也不是什麼新設計，就是之前有線的長相呀，只是沒有線。真的很在意的就等多一點人戴再買吧，哈哈。按照官網購買要排到6個禮拜後的情況，我想以後路上會很常看到的。</p>

<h3>會不會掉？醒著的時候都不會掉</h3>

<p>什麼意思勒？我帶著AirPods慢步，重訓（有時需要躺著），出門坐捷運加上走一大段路，尖峰時刻搭捷運有時難免跟路人碰撞，以上情況都沒有掉過！有線的反而常常搭捷運太擠線勾到還會被扯掉。</p>

<p>唯獨有一次搭客運睡著頭往一邊肩膀倒，然後客運晃阿晃抖阿抖的，那邊的AirPods就掉了&hellip;嚇出一身冷汗，還好那天穿帽T醒來之後AirPods還在我肩膀上。所以，如果你快睡著又剛好身體會晃來晃去就要注意一點了。</p>

<h3>快速跨多裝置使用超方便</h3>

<p>如果你同時有Macbook, iPhone, iPad，而且都使用同一個有線耳機，常常插拔真的頗麻煩。AidPods只要Device都使用同一個Apple ID，每個裝置都不用再額外配對就可以很快速的連接上你的AirPods。</p>

<p>我常常很賭爛Macbook上的耳機孔，真的很難拔，常常只是要上個廁所我就要拔下來再插上手機，回到座位上又要Repeat這個動作。有了AirPods之後就超方便的，只要手機帶著就自動會有AirPods選項讓你選，點一下就切換到手機上了。</p>

<h3>缺點</h3>

<p>使用下來真的沒有感受到什麼缺點，對比有線耳機只有更方便更智慧的感受。真要說的話就是AirPods上面沒有按鈕可以按，也就是說沒有傳統有線上的上下首與大小聲按鈕。AirPods現在只能感應點兩下這個動作，點兩下來叫出Siri或是點兩下暫停/播放。</p>

<p>雖然說是缺點但我的習慣是出門手上都會拿著耳機，基本上手機不離身，所以要上下一首或調音量，把畫面喚醒就可以直接操作了，實際使用上其實也沒有感覺到不便。</p>

<h3>總結</h3>

<p>毆對了！還有價錢。5000多大洋就是考驗每個人用錢價值觀的時刻了。上面舉了那些優點還有缺點，我只能說差不多的錢就功能上還有方便性智慧性等，目前市面上我認為還沒有競爭對手。</p>

<p>對我來說，耳機是我每天必用到的東西，如果每天都能少那麼一點煩惱，比如花時間解開那一坨線, 插拔的動作, 有時會扯到, 原廠有線用久其實真的很容易接觸不良還是要買新的等等，加上上面提的優點，OK 我買單。</p>

<p>我不算盲目的果粉，近期Apple的產品包含iPhone 7跟新Macbook如果有人詢問我意見我都會叫他們再等等，但這個AirPods真的很推，Apple近期難得好作品，預算夠我都會推薦買Der~。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[從Youtube使用Tabbar討論逐漸被棄用的側邊欄]]></title>
    <link href="http://sah.tw/blog/2016/11/20/youtubeshi-yong-tabbar/"/>
    <updated>2016-11-20T11:56:52+08:00</updated>
    <id>http://sah.tw/blog/2016/11/20/youtubeshi-yong-tabbar</id>
    <content type="html"><![CDATA[<h2>側邊欄逐漸被棄用的原因</h2>

<p>iOS版YouTube把Tabbar加上去了。前陣子流行的各種想取代Tabbar導航方式的方案又改回來了。</p>

<p><img src="http://mrshih.github.io/images/2016-11-20-youtubeshi-yong-tabbar.jpeg" alt="image" /></p>

<p>Tabbar是固定出現在下面的（除了播放影片時）。而看了些文章，最主要還是用戶真的太太太太懶，多一丁點步驟都懶得按，所以就乾脆固定在那裡。這樣努力做的各種功能的使用率比較高！</p>

<p>不過Uber是個有趣的例子！Uber用漢堡是因為其他功能的點擊率高不是goal，所以可以用Hamburger menu。</p>

<h2>如何決定要用哪種設計？A/B Testing</h2>

<p>Youtube跟Spotify決定從原本側邊欄轉移到Tabbar都是因為測過A/B Testing，用結果數字來說話。</p>

<p>這其實也牽扯到如何設計A/B Testing？一個APP最關鍵的不是他介面看起來炫不炫，而是最終用戶能不能持續地用你想讓他用的功能。記住If<strong><strong> ,Then</strong></strong> ,Because___.</p>

<p>如果你的變因錯誤的把畫面好看當成目標，那你甚至會覺得隨著畫面滾動把Tabbar隱藏起來是好的。那這樣一來或許畫面變好看，可是面積變多，但你APP整體功能使用率是下降的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary search與Obj-C]]></title>
    <link href="http://sah.tw/blog/2016/11/18/binary-searchyu-obj-c/"/>
    <updated>2016-11-18T16:41:19+08:00</updated>
    <id>http://sah.tw/blog/2016/11/18/binary-searchyu-obj-c</id>
    <content type="html"><![CDATA[<h2>Binary search概念</h2>

<p>Binary search概念其實很簡單，recursive版本實際寫起來很像<a href="http://sah.tw/blog/2016/11/09/objc-quick-sort/">Quick sort in-place</a>版本前面divide的味道。每次的遞迴都把排序後的數列對切一半然後去其中一半來繼續處理，詳細可以看<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">Wiki</a>的介紹。</p>

<h2>Binary search概念轉換成Code</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * @return Retrun index of number in array.
</span><span class='line'> * If number not found in array return false.
</span><span class='line'> */
</span><span class='line'>- (NSNumber *)binarySearchIndexInArray:(NSArray &lt;NSNumber *&gt;*)array forNumber:(NSNumber *)number leftRange:(NSInteger)left rightRange:(NSInteger)right {
</span><span class='line'>    
</span><span class='line'>    if (left &gt; right) {
</span><span class='line'>        return [NSNumber numberWithBool:false];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSInteger midIndex = (left+right)/2;
</span><span class='line'>    NSNumber* mid = array[midIndex];
</span><span class='line'>    
</span><span class='line'>    if (number.floatValue &gt; mid.floatValue) { // 對切的右邊
</span><span class='line'>        return [self binarySearchIndexInArray:array forNumber:number leftRange:midIndex+1 rightRange:right];
</span><span class='line'>    }else if (number.floatValue &lt; mid.floatValue){ // 對切的左邊
</span><span class='line'>        return [self binarySearchIndexInArray:array forNumber:number leftRange:left rightRange:midIndex-1];
</span><span class='line'>    }else{ // equal，找到了
</span><span class='line'>        return  [NSNumber numberWithInteger:midIndex];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>關於搜尋</h2>

<p>這個搜尋法的前提是你的數列要幾經排序好了。這個前置條件才讓我發現我之前一直以為搜尋是有什麼神奇的方法，能夠在一個大數列裡面找到target的位置，現在接觸演算法就理解現實運作方法是先排序之後再用方法搜尋的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickSort與Obj-C]]></title>
    <link href="http://sah.tw/blog/2016/11/09/objc-quick-sort/"/>
    <updated>2016-11-09T10:24:20+08:00</updated>
    <id>http://sah.tw/blog/2016/11/09/objc-quick-sort</id>
    <content type="html"><![CDATA[<h2>Qucik Sort概念</h2>

<p>第一次看到快速排序的許多介紹，可能第一時間腦袋轉不太過來，因為網路介紹常常把虛擬碼翻成步驟，直接敘述，所以腦袋普通像我就會沒辦法意會為什麼要做這個動作。比如後面會提到的In-Place版本交換這個動作就常常不知為何而做。這裡有個<a href="https://www.youtube.com/watch?v=aQiWF4E8flQ">影片</a>是從很高層次想法上去解釋Quick Sort，個人看了之後再想想虛擬碼，也就豁然開朗了。</p>

<h2>Qucik Sort概念轉換成Code</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)quickSortUseExtraMemoryWithData:(NSArray *)data {
</span><span class='line'>
</span><span class='line'>    if (data.count &lt;= 1) { // 到底部了, 不需要排序, 直接回傳
</span><span class='line'>        return data;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    int random = arc4random() % data.count;  // 隨機取用某index當pivot，避免比如排序已經排好的陣列，每次都取index0，會造成時間複雜度O(N^2)，worst case
</span><span class='line'>    NSNumber *pivot = data[random];
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *less = [[NSMutableArray alloc]init];
</span><span class='line'>    NSMutableArray *greater = [[NSMutableArray alloc]init];
</span><span class='line'>    
</span><span class='line'>    for (int i=1; i&lt;=data.count-1; i++ ) {
</span><span class='line'>        if ([(NSNumber *)data[i]floatValue] &gt;= [pivot floatValue]) {
</span><span class='line'>            [greater addObject:data[i]];
</span><span class='line'>        }else {
</span><span class='line'>            [less addObject:data[i]];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *result = [[NSMutableArray alloc]init];
</span><span class='line'>    [result addObjectsFromArray:[self quickSortUseExtraMemoryWithData:less]];
</span><span class='line'>    [result addObject:pivot];
</span><span class='line'>    [result addObjectsFromArray:[self quickSortUseExtraMemoryWithData:greater]];
</span><span class='line'>    
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果常寫有支援記憶體管理語言比如Java或ARC版Obj-C的人可能會直覺寫出這個版本，因為在這幾個語言裡其實常常不用太管記憶體使用量太多這個問題，除非是<code>UIImage</code>等大型物件沒有釋放，不然常常遇到比如<code>NSArray</code>分割其實也就是再開兩個NSArray去存就好了。</p>

<p>上面這個實作方法每次都新開<code>NSArray</code>去存放分割後的子Array，而Quick Sort比Merge Sort好的地方在於它可以改用稱作In-Place的方法，只在同一個陣列做交換，可以避免運用消耗多餘的記憶體空間，參考文獻也寫說實務上也可以增加演算法的效率。</p>

<h2>Qucik Sort In-Place 版本</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSMutableArray *)quickSortInPlaceWithData:(NSMutableArray &lt;NSNumber *&gt;*)data leftIndex:(NSInteger)left rightIndex:(NSInteger)right{
</span><span class='line'>    // 使用in-place法，操作同一個陣列，避免額外消耗多餘記憶體，硬體限制嚴格的環境下使用
</span><span class='line'>    
</span><span class='line'>    if (left &gt; right) { // 底部。代表上一層遞迴切出來，這個sub-array已經只有一個元素，就不用排列了，'這個元素也會是已經就定位的'。
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSNumber *pivot = data[right];
</span><span class='line'>    
</span><span class='line'>    NSInteger processIndexAKAWall = left;
</span><span class='line'>    [data exchangeObjectAtIndex:right withObjectAtIndex:right];// 把pivot移到最後面
</span><span class='line'>    for (int i=(int)left; i&lt;right; i++ ) { // left ... right-1
</span><span class='line'>        if ([data[i]floatValue] &lt; [pivot floatValue]) {
</span><span class='line'>            [data exchangeObjectAtIndex:processIndexAKAWall withObjectAtIndex:i];// 擺到牆的右邊
</span><span class='line'>            processIndexAKAWall = processIndexAKAWall + 1;// 牆往前
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    [data exchangeObjectAtIndex:processIndexAKAWall withObjectAtIndex:right];// 把pivot移到牆的右邊。這個pivot目前已經在正確的index上了。
</span><span class='line'>    
</span><span class='line'>    // 切兩段
</span><span class='line'>    // start by left, end by processIndexAKAWall - 1
</span><span class='line'>    // start by processIndexAKAWall + 1, end by right
</span><span class='line'>    [self quickSortInPlaceWithData:data leftIndex:left rightIndex:processIndexAKAWall - 1];
</span><span class='line'>    [self quickSortInPlaceWithData:data leftIndex:processIndexAKAWall + 1 rightIndex:right];
</span><span class='line'>    
</span><span class='line'>    return data;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>更好用的呼叫方式</h2>

<p>平均空間複雜度更好的In-Place版本，因為只有<code>NSMutableArray</code>可以交換item，所以如果傳入值是是<code>NSArray</code>則呼叫的時候要寫成以下方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray *result = [self quickSortInPlaceWithData:[data mutableCopy] leftIndex:0 rightIndex:data.count-1];</span></code></pre></td></tr></table></div></figure>


<p>而為了可以讓<code>NSArray</code>可以使用，也方便之後做成<code>NSArray</code>的<code>Category</code>，就可以改寫成以下這種較為方便別人使用的方式，因為別人不一定知道Left與Right，也不需要懂實作細節情況下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)quickSort:(NSArray *)data {
</span><span class='line'>    return [self quickSortInPlaceWithData:[data mutableCopy]  leftIndex:0 rightIndex:data.count-1];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MergeSort與Obj-C外加Category與OOP]]></title>
    <link href="http://sah.tw/blog/2016/11/07/objc-merge-sort-category-oop/"/>
    <updated>2016-11-07T00:18:53+08:00</updated>
    <id>http://sah.tw/blog/2016/11/07/objc-merge-sort-category-oop</id>
    <content type="html"><![CDATA[<h2>Merge Sort概念</h2>

<p>跟我一樣原本不知道Merge Sort是什麼碗糕的可以去這個<a href="https://www.youtube.com/watch?v=mzjjRPdH9Jw">影片</a>，這裡有可愛北一女的實際示範，中文的呦。如果英文好那我也是更推薦去看英文的，那資源又更多了。</p>

<h2>Merge Sort概念轉換成Code</h2>

<p>在懂了Merge Sort概念之後，如果對於如何把想法轉換成程式碼沒什麼感覺，可以看一段<a href="https://www.youtube.com/watch?v=es2T6KY45cA&amp;index=3&amp;list=PL2aHrV9pFqNRS2b2XX2BvgQIPKh72xREP">影片</a>，這段影片大概就是程式碼影片化後實際運作的樣子。</p>

<p>Merge Sort有分Recursive跟For loop兩種，但看完影片直覺就是用Recursive比較好做。這是因為你看Merge Sort其實是把一個大問題分成小問題，小問題再分成更小的問題，直到把問題切割成最小單元，再返回來把前一次的結果餵給上一層，之後一層一層的解回去。這是很典型的遞迴場景。
NSMutableArray
上面的問題解決思路在演算法裡面叫做Divide and Conquer，蠻傳神的解釋，把問題分解後在各個擊破。</p>

<h2>Objective-c Implement</h2>

<ul>
<li>Input為一個NSArray，裡面包含N個NSNumber，NSNumber可以為Int或Flot。</li>
<li>Output為一個把Input Array裡面的N個NSNumber由小排序到大的NSArray。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)mergeSortWithData:(NSArray *)data {
</span><span class='line'>    
</span><span class='line'>    if (data.count == 1) {
</span><span class='line'>        // div done here
</span><span class='line'>        // 這裡已經把問題分解成最小單位了，所以就告一段落
</span><span class='line'>        return data;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSInteger divLength = data.count/2;
</span><span class='line'>    NSArray *left = [data subarrayWithRange:NSMakeRange(0, divLength)];
</span><span class='line'>    NSArray *rigth = [data subarrayWithRange:NSMakeRange(divLength, data.count-divLength)];
</span><span class='line'>    
</span><span class='line'>    NSArray&lt;NSNumber*&gt; *mergeArrayA = [self mergeSortWithData:left];
</span><span class='line'>    NSArray&lt;NSNumber*&gt; *mergeArrayB = [self mergeSortWithData:rigth];
</span><span class='line'>    
</span><span class='line'>    NSInteger headOfMergeArrayA = 0;
</span><span class='line'>    NSInteger headOfMergeArrayB = 0;
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *resultArray = [[NSMutableArray alloc]initWithCapacity:mergeArrayA.count+mergeArrayB.count];
</span><span class='line'>    
</span><span class='line'>    Boolean control = true;
</span><span class='line'>    while (control) {
</span><span class='line'>        
</span><span class='line'>        if (headOfMergeArrayA == mergeArrayA.count) {
</span><span class='line'>            //MergeArrayA沒東西了
</span><span class='line'>            //把剩餘的MergeArrayB直接append到resultArray後面
</span><span class='line'>            [resultArray addObjectsFromArray:[mergeArrayB subarrayWithRange:NSMakeRange(headOfMergeArrayB, mergeArrayB.count-headOfMergeArrayB)]];
</span><span class='line'>            control = false;
</span><span class='line'>            break;
</span><span class='line'>        }else if(headOfMergeArrayB == mergeArrayB.count){
</span><span class='line'>            [resultArray addObjectsFromArray:[mergeArrayA subarrayWithRange:NSMakeRange(headOfMergeArrayA, mergeArrayA.count-headOfMergeArrayA)]];
</span><span class='line'>            control = false;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        if ([mergeArrayA[headOfMergeArrayA]floatValue] &gt; [mergeArrayB[headOfMergeArrayB]floatValue]) {
</span><span class='line'>            [resultArray addObject:mergeArrayB[headOfMergeArrayB]];
</span><span class='line'>            headOfMergeArrayB = headOfMergeArrayB + 1;
</span><span class='line'>        }else{
</span><span class='line'>            [resultArray addObject:mergeArrayA[headOfMergeArrayA]];
</span><span class='line'>            headOfMergeArrayA = headOfMergeArrayA + 1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return resultArray;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Do more &ndash; Free Function與Method</h2>

<p>可以看到<code>mergeSortWithData</code>是一個Function，但我自己Obj-C軟體實作的Coding style上如果一個Function的Input有指定要是某個Class，比如這裡就是指定<code>NSArray</code>，那這時候採用Method較好。</p>

<p>但通常很少情況會不指定Input的Clsas，所以實務上會盡量少用Free Function，附帶的好處是可以減少一堆Function散落在專案裡面，也可以盡量DRY（Don&rsquo;t repeat yourself）。</p>

<p>當然，不要過度強調DRY，因為這關係到切架構與抽象化整體的規劃能力，抽象的不好那是會用弄越糟的，但至少在這個簡單的Case裡Merge Sort做成Method絕對是make sense的。</p>

<p>這裡可以練習把Merge Sort用<code>Category</code>的方式做成<code>NSArray</code>的Method。基礎OOP，把一些地方改成<code>Self</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[In-App-Purchase交易模組設計]]></title>
    <link href="http://sah.tw/blog/2016/08/24/iap-payment-model-design/"/>
    <updated>2016-08-24T23:30:18+08:00</updated>
    <id>http://sah.tw/blog/2016/08/24/iap-payment-model-design</id>
    <content type="html"><![CDATA[<p>網路上很多介紹如何運用<code>StoreKit</code>裡面的API在iOS上付款的文章，但實務上因為<code>In-App-Purchase</code>是程式裡面需要密集配合業務需求的部分，如果沒有一個良好抽象化的設計，在高可維護性與彈性，可擴展能力下功夫，一旦業務需求一複雜或反覆迭代更改，就會讓IAP相關的邏輯變得難以修改與維護。</p>

<p>以上原因，所以如何在APP中設計一套可維護可擴展易整合的IAP架構，是開發大型APP與進階開發者應該關心的議題。接下來的文章把IAP付款架構有關執行交易與交易結果處理的這部分，抽象成TNStoreObserver類別。</p>

<h2>StoreObserver</h2>

<p>付款流程是APP根據一組定義在iTunesConnect的商品ID，向Apple Server請求對應的<code>SKPayment</code>物件，裡面包含了Localization的商品名稱與價錢，把這個想成一個商品。而一旦把這個<code>SKPayment</code>物件放到由系統維護的<code>SKPaymentQueue</code>時，這時候就開始進入按指紋，輸入iTunes Store帳密的程序。</p>

<p>而<code>StoreKit</code>說明，當<code>SKPayment</code>加入到<code>SKPaymentQueue</code>後，開發者需要實作一個adopt<code>SKPaymentTransactionObserver</code>protocol的物件，並加入到<code>SKPaymentQueue</code>裡。之後這個Observer就是負責處理各種交易結果。比如成功時就要開啟對應的功能等。</p>

<p>所以這個Class就取名叫StoreObserver，職責是實作<code>SKPaymentTransactionObserver</code>protocol，處理交易完成的後續行為。並負責與<code>SKPaymentQueue</code>互動，比如購買，取回過去的購買紀錄。最後可方便的在任何地方發動購買，然後在需要的地方容易接收到結果。</p>

<p>基於以上需求，開去構思這個模組。</p>

<p>先處理交易的部分，這就是單純與StoreKit串接。以下兩個Public方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 購買SKProduct
</span><span class='line'>// Create and add a payment request to the payment queue
</span><span class='line'>-(void)buy:(SKProduct *)product
</span><span class='line'>{
</span><span class='line'>    SKMutablePayment *payment = [SKMutablePayment paymentWithProduct:product];
</span><span class='line'>  [[SKPaymentQueue defaultQueue] addPayment:payment];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 取回過去完成交易的非消耗品購買與自動續訂紀錄
</span><span class='line'>-(void)restore
</span><span class='line'>{
</span><span class='line'>    [[SKPaymentQueue defaultQueue] restoreCompletedTransactions];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>實作上會把這個<code>StoreObserver</code>做成<code>Singleton</code>，因為APP裡面可能會有許多頁面允許付款，只要<code>[[StoreObserver sharedInstance] buy:product];</code>就可以購買商品。然後因應上面的<code>restore</code>方法，這裡需要一個<code>NSArray</code>來裝取回的商品們，命名為<code>productsRestored</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (StoreObserver *)sharedInstance
</span><span class='line'>{
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    static StoreObserver * storeObserverSharedInstance;
</span><span class='line'>    
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        storeObserverSharedInstance = [[StoreObserver alloc] init];
</span><span class='line'>    });
</span><span class='line'>    return storeObserverSharedInstance;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>- (instancetype)init
</span><span class='line'>{
</span><span class='line'>  self = [super init];
</span><span class='line'>  if (self != nil)
</span><span class='line'>    {
</span><span class='line'>        _productsRestored = [[NSMutableArray alloc] initWithCapacity:0];
</span><span class='line'>    }
</span><span class='line'>  return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>這邊重要的來了，如果程式的某個地方呼叫了<code>StoreObserver</code>的<code>buy</code>發法，之後<code>StoreObserver</code>收到交易完成的資訊，而APP裡面可能會有很多地方因為這個交易而產生UI上的變化，比如買了一部影片，影片要開始播放，影片櫃需要新增新影片，會員的購買紀律需要增加一筆。該怎麼通知那麼多地方？這裡用了<code>NSNotificationCenter</code>。</p>

<p>為什麼呢？因為在上述一對多的狀況下，<code>StoreObserver</code>會被設計成它不關心那些畫面或地方需要這些訊息。但它會把資料準備好，接著廣播。</p>

<p>當通知的人不關心他會通知到誰，但可能需要被通知的人很多時，<code>NSNotificationCenter</code>機制就派上用場了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString * const TNIAPPurchaseNotification = @"TNIAPPurchaseNotification";</span></code></pre></td></tr></table></div></figure>


<p>再來是讓接收廣播的地方容易做處理。在這個Class裡面我們設置三個Property，<code>status</code>，<code>message</code>和<code>purchasedID</code>。當這個Class實作<code>SKPaymentTransactionObserver</code>時，根據收到的資訊做整理，讓接收的人可以很方便利用交易結果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_ENUM(NSInteger, TNIAPPurchaseNotificationStatus)
</span><span class='line'>{
</span><span class='line'>    TNIAPPurchaseFailed, // Indicate that the purchase was unsuccessful
</span><span class='line'>    TNIAPPurchaseSucceeded, // Indicate that the purchase was successful
</span><span class='line'>    TNIAPRestoredFailed, // Indicate that restore products was unsuccessful
</span><span class='line'>    TNIAPRestoredSucceeded // Indicate that restore products was successful
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>@property (nonatomic) TNIAPPurchaseNotificationStatus status;
</span><span class='line'>@property (nonatomic, copy) NSString *purchasedID;
</span><span class='line'>@property (nonatomic, copy) NSString *message;</span></code></pre></td></tr></table></div></figure>


<p>比如當我們實作的<code>SKPaymentTransactionObserver</code>方法被<code>SKPaymentQueue</code>呼叫時，整理一下再POST Notification出去</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Called when an error occur while restoring purchases. Notify the user about the error.
</span><span class='line'>- (void)paymentQueue:(SKPaymentQueue *)queue restoreCompletedTransactionsFailedWithError:(NSError *)error
</span><span class='line'>{
</span><span class='line'>    if (error.code != SKErrorPaymentCancelled)
</span><span class='line'>    {
</span><span class='line'>        self.status = IAPRestoredFailed;
</span><span class='line'>        self.message = error.localizedDescription;
</span><span class='line'>        [[NSNotificationCenter defaultCenter] postNotificationName:TNIAPPurchaseNotification object:self];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>實際運作</h2>

<p>這邊我們不考慮要怎麼取得到SKPayment物件，因為這部分邏輯不在<code>StoreObserver</code>負責範圍內。</p>

<h3>在任何地方容易的發動購買</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SKProduct *product = (SKProduct *)productRequestResponse[indexPath.row];
</span><span class='line'>        // Attempt to purchase the tapped product
</span><span class='line'>        [[TNStoreObserver sharedInstance] buy:product];</span></code></pre></td></tr></table></div></figure>


<h3>在需要的地方容易收到並做處理</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[NSNotificationCenter defaultCenter] addObserver:self
</span><span class='line'>                                             selector:@selector(handlePurchasesNotification:)
</span><span class='line'>                                                 name:TNIAPPurchaseNotification
</span><span class='line'>                                               object:[StoreObserver sharedInstance]];
</span><span class='line'>
</span><span class='line'>// Update the UI according to the purchase request notification result
</span><span class='line'>-(void)handlePurchasesNotification:(NSNotification *)notification
</span><span class='line'>{
</span><span class='line'>    StoreObserver *purchasesNotification = (StoreObserver *)notification.object;
</span><span class='line'>    
</span><span class='line'>    IAPPurchaseNotificationStatus status = (IAPPurchaseNotificationStatus)purchasesNotification.status;
</span><span class='line'>    NSString *message = purchasesNotification.message;
</span><span class='line'>    NSString *purchasedID = purchasesNotification.purchasedID;
</span><span class='line'>   
</span><span class='line'>
</span><span class='line'>  switch (status)
</span><span class='line'>    {
</span><span class='line'>        case IAPPurchaseFailed:
</span><span class='line'>            //購買失敗...
</span><span class='line'>          break;
</span><span class='line'>            
</span><span class='line'>        case IAPDownloadSucceeded:
</span><span class='line'>        {
</span><span class='line'>            //購買成功...
</span><span class='line'>        }
</span><span class='line'>          break;
</span><span class='line'>        
</span><span class='line'>        case IAPRestoredSucceeded:
</span><span class='line'>        {
</span><span class='line'>            //回復成功...
</span><span class='line'>        }
</span><span class='line'>            break;
</span><span class='line'>            
</span><span class='line'>        case IAPRestoredFailed:
</span><span class='line'>            //回復失敗...
</span><span class='line'>            break;
</span><span class='line'>  } 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
